{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\n\nconst wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\n\nfunction pd(event) {\n  const retv = privateData.get(event);\n  console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n  return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\n\n\nfunction setCancelFlag(data) {\n  if (data.passiveListener != null) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n    }\n\n    return;\n  }\n\n  if (!data.event.cancelable) {\n    return;\n  }\n\n  data.canceled = true;\n\n  if (typeof data.event.preventDefault === \"function\") {\n    data.event.preventDefault();\n  }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\n\n\nfunction Event(eventTarget, event) {\n  privateData.set(this, {\n    eventTarget,\n    event,\n    eventPhase: 2,\n    currentTarget: eventTarget,\n    canceled: false,\n    stopped: false,\n    immediateStopped: false,\n    passiveListener: null,\n    timeStamp: event.timeStamp || Date.now()\n  }); // https://heycam.github.io/webidl/#Unforgeable\n\n  Object.defineProperty(this, \"isTrusted\", {\n    value: false,\n    enumerable: true\n  }); // Define accessors\n\n  const keys = Object.keys(event);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (!(key in this)) {\n      Object.defineProperty(this, key, defineRedirectDescriptor(key));\n    }\n  }\n} // Should be enumerable, but class methods are not enumerable.\n\n\nEvent.prototype = {\n  /**\n   * The type of this event.\n   * @type {string}\n   */\n  get type() {\n    return pd(this).event.type;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get target() {\n    return pd(this).eventTarget;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    return pd(this).currentTarget;\n  },\n\n  /**\n   * @returns {EventTarget[]} The composed path of this event.\n   */\n  composedPath() {\n    const currentTarget = pd(this).currentTarget;\n\n    if (currentTarget == null) {\n      return [];\n    }\n\n    return [currentTarget];\n  },\n\n  /**\n   * Constant of NONE.\n   * @type {number}\n   */\n  get NONE() {\n    return 0;\n  },\n\n  /**\n   * Constant of CAPTURING_PHASE.\n   * @type {number}\n   */\n  get CAPTURING_PHASE() {\n    return 1;\n  },\n\n  /**\n   * Constant of AT_TARGET.\n   * @type {number}\n   */\n  get AT_TARGET() {\n    return 2;\n  },\n\n  /**\n   * Constant of BUBBLING_PHASE.\n   * @type {number}\n   */\n  get BUBBLING_PHASE() {\n    return 3;\n  },\n\n  /**\n   * The target of this event.\n   * @type {number}\n   */\n  get eventPhase() {\n    return pd(this).eventPhase;\n  },\n\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopPropagation() {\n    const data = pd(this);\n    data.stopped = true;\n\n    if (typeof data.event.stopPropagation === \"function\") {\n      data.event.stopPropagation();\n    }\n  },\n\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopImmediatePropagation() {\n    const data = pd(this);\n    data.stopped = true;\n    data.immediateStopped = true;\n\n    if (typeof data.event.stopImmediatePropagation === \"function\") {\n      data.event.stopImmediatePropagation();\n    }\n  },\n\n  /**\n   * The flag to be bubbling.\n   * @type {boolean}\n   */\n  get bubbles() {\n    return Boolean(pd(this).event.bubbles);\n  },\n\n  /**\n   * The flag to be cancelable.\n   * @type {boolean}\n   */\n  get cancelable() {\n    return Boolean(pd(this).event.cancelable);\n  },\n\n  /**\n   * Cancel this event.\n   * @returns {void}\n   */\n  preventDefault() {\n    setCancelFlag(pd(this));\n  },\n\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    return pd(this).canceled;\n  },\n\n  /**\n   * The flag to be composed.\n   * @type {boolean}\n   */\n  get composed() {\n    return Boolean(pd(this).event.composed);\n  },\n\n  /**\n   * The unix time of this event.\n   * @type {number}\n   */\n  get timeStamp() {\n    return pd(this).timeStamp;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   * @deprecated\n   */\n  get srcElement() {\n    return pd(this).eventTarget;\n  },\n\n  /**\n   * The flag to stop event bubbling.\n   * @type {boolean}\n   * @deprecated\n   */\n  get cancelBubble() {\n    return pd(this).stopped;\n  },\n\n  set cancelBubble(value) {\n    if (!value) {\n      return;\n    }\n\n    const data = pd(this);\n    data.stopped = true;\n\n    if (typeof data.event.cancelBubble === \"boolean\") {\n      data.event.cancelBubble = true;\n    }\n  },\n\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   * @deprecated\n   */\n  get returnValue() {\n    return !pd(this).canceled;\n  },\n\n  set returnValue(value) {\n    if (!value) {\n      setCancelFlag(pd(this));\n    }\n  },\n\n  /**\n   * Initialize this event object. But do nothing under event dispatching.\n   * @param {string} type The event type.\n   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n   * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n   * @deprecated\n   */\n  initEvent() {// Do nothing.\n  }\n\n}; // `constructor` is not enumerable.\n\nObject.defineProperty(Event.prototype, \"constructor\", {\n  value: Event,\n  configurable: true,\n  writable: true\n}); // Ensure `event instanceof window.Event` is `true`.\n\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n  Object.setPrototypeOf(Event.prototype, window.Event.prototype); // Make association for wrappers.\n\n  wrappers.set(window.Event.prototype, Event);\n}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\n\n\nfunction defineRedirectDescriptor(key) {\n  return {\n    get() {\n      return pd(this).event[key];\n    },\n\n    set(value) {\n      pd(this).event[key] = value;\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\n\n\nfunction defineCallDescriptor(key) {\n  return {\n    value() {\n      const event = pd(this).event;\n      return event[key].apply(event, arguments);\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\n\n\nfunction defineWrapper(BaseEvent, proto) {\n  const keys = Object.keys(proto);\n\n  if (keys.length === 0) {\n    return BaseEvent;\n  }\n  /** CustomEvent */\n\n\n  function CustomEvent(eventTarget, event) {\n    BaseEvent.call(this, eventTarget, event);\n  }\n\n  CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n    constructor: {\n      value: CustomEvent,\n      configurable: true,\n      writable: true\n    }\n  }); // Define accessors.\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (!(key in BaseEvent.prototype)) {\n      const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n      const isFunc = typeof descriptor.value === \"function\";\n      Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n    }\n  }\n\n  return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\n\n\nfunction getWrapper(proto) {\n  if (proto == null || proto === Object.prototype) {\n    return Event;\n  }\n\n  let wrapper = wrappers.get(proto);\n\n  if (wrapper == null) {\n    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n    wrappers.set(proto, wrapper);\n  }\n\n  return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\n\n\nfunction wrapEvent(eventTarget, event) {\n  const Wrapper = getWrapper(Object.getPrototypeOf(event));\n  return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\n\n\nfunction isStopped(event) {\n  return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\n\n\nfunction setEventPhase(event, eventPhase) {\n  pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\n\n\nfunction setCurrentTarget(event, currentTarget) {\n  pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\n\n\nfunction setPassiveListener(event, passiveListener) {\n  pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\n\n\nconst listenersMap = new WeakMap(); // Listener types\n\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\n\nfunction isObject(x) {\n  return x !== null && typeof x === \"object\"; //eslint-disable-line no-restricted-syntax\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\n\n\nfunction getListeners(eventTarget) {\n  const listeners = listenersMap.get(eventTarget);\n\n  if (listeners == null) {\n    throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n  }\n\n  return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\n\n\nfunction defineEventAttributeDescriptor(eventName) {\n  return {\n    get() {\n      const listeners = getListeners(this);\n      let node = listeners.get(eventName);\n\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          return node.listener;\n        }\n\n        node = node.next;\n      }\n\n      return null;\n    },\n\n    set(listener) {\n      if (typeof listener !== \"function\" && !isObject(listener)) {\n        listener = null; // eslint-disable-line no-param-reassign\n      }\n\n      const listeners = getListeners(this); // Traverse to the tail while removing old value.\n\n      let prev = null;\n      let node = listeners.get(eventName);\n\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          // Remove old value.\n          if (prev !== null) {\n            prev.next = node.next;\n          } else if (node.next !== null) {\n            listeners.set(eventName, node.next);\n          } else {\n            listeners.delete(eventName);\n          }\n        } else {\n          prev = node;\n        }\n\n        node = node.next;\n      } // Add new value.\n\n\n      if (listener !== null) {\n        const newNode = {\n          listener,\n          listenerType: ATTRIBUTE,\n          passive: false,\n          once: false,\n          next: null\n        };\n\n        if (prev === null) {\n          listeners.set(eventName, newNode);\n        } else {\n          prev.next = newNode;\n        }\n      }\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\n\n\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n  Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\n\n\nfunction defineCustomEventTarget(eventNames) {\n  /** CustomEventTarget */\n  function CustomEventTarget() {\n    EventTarget.call(this);\n  }\n\n  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n    constructor: {\n      value: CustomEventTarget,\n      configurable: true,\n      writable: true\n    }\n  });\n\n  for (let i = 0; i < eventNames.length; ++i) {\n    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n  }\n\n  return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\n\n\nfunction EventTarget() {\n  /*eslint-disable consistent-return */\n  if (this instanceof EventTarget) {\n    listenersMap.set(this, new Map());\n    return;\n  }\n\n  if (arguments.length === 1 && Array.isArray(arguments[0])) {\n    return defineCustomEventTarget(arguments[0]);\n  }\n\n  if (arguments.length > 0) {\n    const types = new Array(arguments.length);\n\n    for (let i = 0; i < arguments.length; ++i) {\n      types[i] = arguments[i];\n    }\n\n    return defineCustomEventTarget(types);\n  }\n\n  throw new TypeError(\"Cannot call a class as a function\");\n  /*eslint-enable consistent-return */\n} // Should be enumerable, but class methods are not enumerable.\n\n\nEventTarget.prototype = {\n  /**\n   * Add a given listener to this event target.\n   * @param {string} eventName The event name to add.\n   * @param {Function} listener The listener to add.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  addEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n\n    if (typeof listener !== \"function\" && !isObject(listener)) {\n      throw new TypeError(\"'listener' should be a function or an object.\");\n    }\n\n    const listeners = getListeners(this);\n    const optionsIsObj = isObject(options);\n    const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    const newNode = {\n      listener,\n      listenerType,\n      passive: optionsIsObj && Boolean(options.passive),\n      once: optionsIsObj && Boolean(options.once),\n      next: null\n    }; // Set it as the first node if the first node is null.\n\n    let node = listeners.get(eventName);\n\n    if (node === undefined) {\n      listeners.set(eventName, newNode);\n      return;\n    } // Traverse to the tail while checking duplication..\n\n\n    let prev = null;\n\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        // Should ignore duplication.\n        return;\n      }\n\n      prev = node;\n      node = node.next;\n    } // Add it.\n\n\n    prev.next = newNode;\n  },\n\n  /**\n   * Remove a given listener from this event target.\n   * @param {string} eventName The event name to remove.\n   * @param {Function} listener The listener to remove.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  removeEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n\n    const listeners = getListeners(this);\n    const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    let prev = null;\n    let node = listeners.get(eventName);\n\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n\n        return;\n      }\n\n      prev = node;\n      node = node.next;\n    }\n  },\n\n  /**\n   * Dispatch a given event.\n   * @param {Event|{type:string}} event The event to dispatch.\n   * @returns {boolean} `false` if canceled.\n   */\n  dispatchEvent(event) {\n    if (event == null || typeof event.type !== \"string\") {\n      throw new TypeError('\"event.type\" should be a string.');\n    } // If listeners aren't registered, terminate.\n\n\n    const listeners = getListeners(this);\n    const eventName = event.type;\n    let node = listeners.get(eventName);\n\n    if (node == null) {\n      return true;\n    } // Since we cannot rewrite several properties, so wrap object.\n\n\n    const wrappedEvent = wrapEvent(this, event); // This doesn't process capturing phase and bubbling phase.\n    // This isn't participating in a tree.\n\n    let prev = null;\n\n    while (node != null) {\n      // Remove this listener if it's once\n      if (node.once) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n      } else {\n        prev = node;\n      } // Call this listener\n\n\n      setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n\n      if (typeof node.listener === \"function\") {\n        try {\n          node.listener.call(this, wrappedEvent);\n        } catch (err) {\n          if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(err);\n          }\n        }\n      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n        node.listener.handleEvent(wrappedEvent);\n      } // Break if `event.stopImmediatePropagation` was called.\n\n\n      if (isStopped(wrappedEvent)) {\n        break;\n      }\n\n      node = node.next;\n    }\n\n    setPassiveListener(wrappedEvent, null);\n    setEventPhase(wrappedEvent, 0);\n    setCurrentTarget(wrappedEvent, null);\n    return !wrappedEvent.defaultPrevented;\n  }\n\n}; // `constructor` is not enumerable.\n\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n  value: EventTarget,\n  configurable: true,\n  writable: true\n}); // Ensure `eventTarget instanceof window.EventTarget` is `true`.\n\nif (typeof window !== \"undefined\" && typeof window.EventTarget !== \"undefined\") {\n  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };","map":{"version":3,"mappings":"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","names":["privateData","WeakMap","wrappers","pd","event","retv","get","console","assert","setCancelFlag","data","passiveListener","error","cancelable","canceled","preventDefault","Event","eventTarget","set","eventPhase","currentTarget","stopped","immediateStopped","timeStamp","Date","now","Object","defineProperty","value","enumerable","keys","i","length","key","defineRedirectDescriptor","prototype","type","target","composedPath","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","stopPropagation","stopImmediatePropagation","bubbles","Boolean","defaultPrevented","composed","srcElement","cancelBubble","returnValue","initEvent","configurable","writable","window","setPrototypeOf","defineCallDescriptor","apply","arguments","defineWrapper","BaseEvent","proto","CustomEvent","call","create","constructor","descriptor","getOwnPropertyDescriptor","isFunc","getWrapper","wrapper","getPrototypeOf","wrapEvent","Wrapper","isStopped","setEventPhase","setCurrentTarget","setPassiveListener","listenersMap","CAPTURE","BUBBLE","ATTRIBUTE","isObject","x","getListeners","listeners","TypeError","defineEventAttributeDescriptor","eventName","node","listenerType","listener","next","prev","delete","newNode","passive","once","defineEventAttribute","eventTargetPrototype","defineCustomEventTarget","eventNames","CustomEventTarget","EventTarget","Map","Array","isArray","types","addEventListener","options","optionsIsObj","capture","undefined","removeEventListener","dispatchEvent","wrappedEvent","err","handleEvent"],"sources":["../src/event.mjs","../src/event-target.mjs"],"sourcesContent":["/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap()\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap()\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event)\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            )\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault()\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    })\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true })\n\n    // Define accessors\n    const keys = Object.keys(event)\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key))\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation()\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        data.immediateStopped = true\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation()\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this))\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this))\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype)\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event)\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto)\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event)\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    })\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key)\n            const isFunc = typeof descriptor.value === \"function\"\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            )\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto)\n        wrappers.set(proto, wrapper)\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nexport function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event))\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nexport function isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nexport function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nexport function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nexport function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener\n}\n","import {\n    isStopped,\n    setCurrentTarget,\n    setEventPhase,\n    setPassiveListener,\n    wrapEvent,\n} from \"./event.mjs\"\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap()\n\n// Listener types\nconst CAPTURE = 1\nconst BUBBLE = 2\nconst ATTRIBUTE = 3\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget)\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this)\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this)\n\n            // Traverse to the tail while removing old value.\n            let prev = null\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next)\n                    } else {\n                        listeners.delete(eventName)\n                    }\n                } else {\n                    prev = node\n                }\n\n                node = node.next\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                }\n                if (prev === null) {\n                    listeners.set(eventName, newNode)\n                } else {\n                    prev.next = newNode\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    )\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this)\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    })\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i])\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map())\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length)\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i]\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this)\n        const optionsIsObj = isObject(options)\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        }\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName)\n        if (node === undefined) {\n            listeners.set(eventName, newNode)\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node\n            node = node.next\n        }\n\n        // Add it.\n        prev.next = newNode\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this)\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n\n        let prev = null\n        let node = listeners.get(eventName)\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n                return\n            }\n\n            prev = node\n            node = node.next\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this)\n        const eventName = event.type\n        let node = listeners.get(eventName)\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event)\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n            } else {\n                prev = node\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            )\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent)\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err)\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent)\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next\n        }\n        setPassiveListener(wrappedEvent, null)\n        setEventPhase(wrappedEvent, 0)\n        setCurrentTarget(wrappedEvent, null)\n\n        return !wrappedEvent.defaultPrevented\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype)\n}\n\nexport { defineEventAttribute, EventTarget }\nexport default EventTarget\n"]},"metadata":{},"sourceType":"module"}