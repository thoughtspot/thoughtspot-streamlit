{"ast":null,"code":"import _slicedToArray from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { DataType } from './type';\nimport { selectArgs } from './util/args';\nimport { selectFieldArgs } from './util/args';\nimport { instance as comparer } from './visitor/typecomparator';\nexport var Schema = /*#__PURE__*/function (_Symbol$toStringTag) {\n  function Schema() {\n    var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var metadata = arguments.length > 1 ? arguments[1] : undefined;\n    var dictionaries = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, Schema);\n\n    this.fields = fields || [];\n    this.metadata = metadata || new Map();\n\n    if (!dictionaries) {\n      dictionaries = generateDictionaryMap(fields);\n    }\n\n    this.dictionaries = dictionaries;\n  }\n  /** @nocollapse */\n\n\n  _createClass(Schema, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'Schema';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Schema<{ \".concat(this.fields.map(function (f, i) {\n        return \"\".concat(i, \": \").concat(f);\n      }).join(', '), \" }>\");\n    }\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(other) {\n      return comparer.compareSchemas(this, other);\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {\n        columnNames[_key] = arguments[_key];\n      }\n\n      var names = columnNames.reduce(function (xs, x) {\n        return (xs[x] = true) && xs;\n      }, Object.create(null));\n      return new Schema(this.fields.filter(function (f) {\n        return names[f.name];\n      }), this.metadata);\n    }\n  }, {\n    key: \"selectAt\",\n    value: function selectAt() {\n      var _this = this;\n\n      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        columnIndices[_key2] = arguments[_key2];\n      }\n\n      return new Schema(columnIndices.map(function (i) {\n        return _this.fields[i];\n      }).filter(Boolean), this.metadata);\n    }\n  }, {\n    key: \"assign\",\n    value: function assign() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var other = args[0] instanceof Schema ? args[0] : new Schema(selectArgs(Field, args));\n\n      var curFields = _toConsumableArray(this.fields);\n\n      var metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n      var newFields = other.fields.filter(function (f2) {\n        var i = curFields.findIndex(function (f) {\n          return f.name === f2.name;\n        });\n        return ~i ? (curFields[i] = f2.clone({\n          metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n        })) && false : true;\n      });\n      var newDictionaries = generateDictionaryMap(newFields, new Map());\n      return new Schema([].concat(_toConsumableArray(curFields), _toConsumableArray(newFields)), metadata, new Map([].concat(_toConsumableArray(this.dictionaries), _toConsumableArray(newDictionaries))));\n    }\n  }], [{\n    key: \"from\",\n    value: function from() {\n      return Schema.new(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"new\",\n    value: function _new() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return new Schema(selectFieldArgs(args)[0]);\n    }\n  }]);\n\n  return Schema;\n}(Symbol.toStringTag);\nexport var Field = /*#__PURE__*/function (_Symbol$toStringTag2) {\n  function Field(name, type) {\n    var nullable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var metadata = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, Field);\n\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata || new Map();\n  }\n  /** @nocollapse */\n\n\n  _createClass(Field, [{\n    key: \"typeId\",\n    get: function get() {\n      return this.type.typeId;\n    }\n  }, {\n    key: _Symbol$toStringTag2,\n    get: function get() {\n      return 'Field';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.name, \": \").concat(this.type);\n    }\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(other) {\n      return comparer.compareField(this, other);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var _args, _args2, _args2$, _args2$2, _args2$3, _args2$4, _args$, _args$$name, _args$$type, _args$$nullable, _args$$metadata;\n\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      var name = args[0],\n          type = args[1],\n          nullable = args[2],\n          metadata = args[3];\n      !args[0] || typeof args[0] !== 'object' ? (_args = args, _args2 = _slicedToArray(_args, 4), _args2$ = _args2[0], name = _args2$ === void 0 ? this.name : _args2$, _args2$2 = _args2[1], type = _args2$2 === void 0 ? this.type : _args2$2, _args2$3 = _args2[2], nullable = _args2$3 === void 0 ? this.nullable : _args2$3, _args2$4 = _args2[3], metadata = _args2$4 === void 0 ? this.metadata : _args2$4, _args) : (_args$ = args[0], _args$$name = _args$.name, name = _args$$name === void 0 ? this.name : _args$$name, _args$$type = _args$.type, type = _args$$type === void 0 ? this.type : _args$$type, _args$$nullable = _args$.nullable, nullable = _args$$nullable === void 0 ? this.nullable : _args$$nullable, _args$$metadata = _args$.metadata, metadata = _args$$metadata === void 0 ? this.metadata : _args$$metadata, _args$);\n      return Field.new(name, type, nullable, metadata);\n    }\n  }], [{\n    key: \"new\",\n    value: function _new() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      var name = args[0],\n          type = args[1],\n          nullable = args[2],\n          metadata = args[3];\n\n      if (args[0] && typeof args[0] === 'object') {\n        name = args[0].name;\n        type === undefined && (type = args[0].type);\n        nullable === undefined && (nullable = args[0].nullable);\n        metadata === undefined && (metadata = args[0].metadata);\n      }\n\n      return new Field(\"\".concat(name), type, nullable, metadata);\n    }\n  }]);\n\n  return Field;\n}(Symbol.toStringTag);\n/** @ignore */\n\nfunction mergeMaps(m1, m2) {\n  return new Map([].concat(_toConsumableArray(m1 || new Map()), _toConsumableArray(m2 || new Map())));\n}\n/** @ignore */\n\n\nfunction generateDictionaryMap(fields) {\n  var dictionaries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n\n  for (var i = -1, n = fields.length; ++i < n;) {\n    var field = fields[i];\n    var type = field.type;\n\n    if (DataType.isDictionary(type)) {\n      if (!dictionaries.has(type.id)) {\n        dictionaries.set(type.id, type.dictionary);\n      } else if (dictionaries.get(type.id) !== type.dictionary) {\n        throw new Error(\"Cannot create Schema containing two different dictionaries with the same Id\");\n      }\n    }\n\n    if (type.children && type.children.length > 0) {\n      generateDictionaryMap(type.children, dictionaries);\n    }\n  }\n\n  return dictionaries;\n} // Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\n\n\nSchema.prototype.fields = null;\nSchema.prototype.metadata = null;\nSchema.prototype.dictionaries = null;\nField.prototype.type = null;\nField.prototype.name = null;\nField.prototype.nullable = null;\nField.prototype.metadata = null;","map":{"version":3,"mappings":"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","names":["DataType","selectArgs","selectFieldArgs","instance","comparer","Schema","fields","metadata","dictionaries","Map","generateDictionaryMap","map","f","i","join","other","compareSchemas","columnNames","names","reduce","xs","x","Object","create","filter","name","columnIndices","Boolean","args","Field","curFields","mergeMaps","newFields","f2","findIndex","clone","newDictionaries","new","Symbol","toStringTag","type","nullable","typeId","compareField","undefined","m1","m2","n","length","field","isDictionary","has","id","set","dictionary","get","Error","children","prototype"],"sources":["schema.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from './data';\nimport { Vector } from './vector';\nimport { DataType } from './type';\nimport { selectArgs } from './util/args';\nimport { selectFieldArgs } from './util/args';\nimport { instance as comparer } from './visitor/typecomparator';\n\ntype VectorMap = { [key: string]: Vector };\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\ntype ChildData<T extends { [key: string]: DataType }> = T[keyof T][] | Data<T[keyof T]>[] | Vector<T[keyof T]>[];\n\nexport class Schema<T extends { [key: string]: DataType } = any> {\n\n    public static from<T extends { [key: string]: DataType } = any>(children: T): Schema<T>;\n    public static from<T extends VectorMap = any>(children: T): Schema<{ [P in keyof T]: T[P]['type'] }>;\n    public static from<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): Schema<T>;\n    /** @nocollapse */\n    public static from(...args: any[]) {\n        return Schema.new(args[0], args[1]);\n    }\n\n    public static new<T extends { [key: string]: DataType } = any>(children: T): Schema<T>;\n    public static new<T extends VectorMap = any>(children: T): Schema<{ [P in keyof T]: T[P]['type'] }>;\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): Schema<T>;\n    /** @nocollapse */\n    public static new(...args: any[]) {\n        return new Schema(selectFieldArgs(args)[0]);\n    }\n\n    public readonly fields: Field<T[keyof T]>[];\n    public readonly metadata: Map<string, string>;\n    public readonly dictionaries: Map<number, DataType>;\n\n    constructor(fields: Field[] = [],\n                metadata?: Map<string, string> | null,\n                dictionaries?: Map<number, DataType> | null) {\n        this.fields = (fields || []) as Field<T[keyof T]>[];\n        this.metadata = metadata || new Map();\n        if (!dictionaries) {\n            dictionaries = generateDictionaryMap(fields);\n        }\n        this.dictionaries = dictionaries;\n    }\n    public get [Symbol.toStringTag]() { return 'Schema'; }\n    public toString() {\n        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\n    }\n\n    public compareTo(other?: Schema | null): other is Schema<T> {\n        return comparer.compareSchemas(this, other);\n    }\n\n    public select<K extends keyof T = any>(...columnNames: K[]) {\n        const names = columnNames.reduce((xs, x) => (xs[x] = true) && xs, Object.create(null));\n        return new Schema<{ [P in K]: T[P] }>(this.fields.filter((f) => names[f.name]), this.metadata);\n    }\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\n        return new Schema<{ [key: string]: K }>(columnIndices.map((i) => this.fields[i]).filter(Boolean), this.metadata);\n    }\n\n    public assign<R extends { [key: string]: DataType } = any>(schema: Schema<R>): Schema<T & R>;\n    public assign<R extends { [key: string]: DataType } = any>(...fields: (Field<R[keyof R]> | Field<R[keyof R]>[])[]): Schema<T & R>;\n    public assign<R extends { [key: string]: DataType } = any>(...args: (Schema<R> | Field<R[keyof R]> | Field<R[keyof R]>[])[]) {\n\n        const other = args[0] instanceof Schema ? args[0] as Schema<R>\n            : new Schema<R>(selectArgs<Field<R[keyof R]>>(Field, args));\n\n        const curFields = [...this.fields] as Field[];\n        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n        const newFields = other.fields.filter((f2) => {\n            const i = curFields.findIndex((f) => f.name === f2.name);\n            return ~i ? (curFields[i] = f2.clone({\n                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n            })) && false : true;\n        }) as Field[];\n\n        const newDictionaries = generateDictionaryMap(newFields, new Map());\n\n        return new Schema<T & R>(\n            [...curFields, ...newFields], metadata,\n            new Map([...this.dictionaries, ...newDictionaries])\n        );\n    }\n}\n\nexport class Field<T extends DataType = any> {\n\n    public static new<T extends DataType = any>(props: { name: string | number, type: T, nullable?: boolean, metadata?: Map<string, string> | null }): Field<T>;\n    public static new<T extends DataType = any>(name: string | number | Field<T>, type: T, nullable?: boolean, metadata?: Map<string, string> | null): Field<T>;\n    /** @nocollapse */\n    public static new<T extends DataType = any>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        if (args[0] && typeof args[0] === 'object') {\n            ({ name } = args[0]);\n            (type === undefined) && (type = args[0].type);\n            (nullable === undefined) && (nullable = args[0].nullable);\n            (metadata === undefined) && (metadata = args[0].metadata);\n        }\n        return new Field<T>(`${name}`, type, nullable, metadata);\n    }\n\n    public readonly type: T;\n    public readonly name: string;\n    public readonly nullable: boolean;\n    public readonly metadata: Map<string, string>;\n\n    constructor(name: string, type: T, nullable = false, metadata?: Map<string, string> | null) {\n        this.name = name;\n        this.type = type;\n        this.nullable = nullable;\n        this.metadata = metadata || new Map();\n    }\n\n    public get typeId() { return this.type.typeId; }\n    public get [Symbol.toStringTag]() { return 'Field'; }\n    public toString() { return `${this.name}: ${this.type}`; }\n    public compareTo(other?: Field | null): other is Field<T> {\n        return comparer.compareField(this, other);\n    }\n    public clone<R extends DataType = T>(props: { name?: string | number, type?: R, nullable?: boolean, metadata?: Map<string, string> | null }): Field<R>;\n    public clone<R extends DataType = T>(name?: string | number | Field<T>, type?: R, nullable?: boolean, metadata?: Map<string, string> | null): Field<R>;\n    public clone<R extends DataType = T>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        (!args[0] || typeof args[0] !== 'object')\n            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)\n            : ({name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata} = args[0]);\n        return Field.new<R>(name, type, nullable, metadata);\n    }\n}\n\n/** @ignore */\nfunction mergeMaps<TKey, TVal>(m1?: Map<TKey, TVal> | null, m2?: Map<TKey, TVal> | null): Map<TKey, TVal> {\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n\n/** @ignore */\nfunction generateDictionaryMap(fields: Field[], dictionaries = new Map<number, DataType>()): Map<number, DataType> {\n\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                dictionaries.set(type.id, type.dictionary);\n            } else if (dictionaries.get(type.id) !== type.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            generateDictionaryMap(type.children, dictionaries);\n        }\n    }\n\n    return dictionaries;\n}\n\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\n(Schema.prototype as any).fields = null;\n(Schema.prototype as any).metadata = null;\n(Schema.prototype as any).dictionaries = null;\n\n(Field.prototype as any).type = null;\n(Field.prototype as any).name = null;\n(Field.prototype as any).nullable = null;\n(Field.prototype as any).metadata = null;\n"]},"metadata":{},"sourceType":"module"}