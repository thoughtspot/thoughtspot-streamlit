{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _awaitAsyncGenerator from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(_fromIterable);\n\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer';\n/** @ignore */\n\nexport default {\n  fromIterable: function fromIterable(source) {\n    return pump(_fromIterable(source));\n  },\n  fromAsyncIterable: function fromAsyncIterable(source) {\n    return pump(_fromAsyncIterable2(source));\n  },\n  fromDOMStream: function fromDOMStream(source) {\n    return pump(_fromDOMStream2(source));\n  },\n  fromNodeStream: function fromNodeStream(stream) {\n    return pump(_fromNodeStream2(stream));\n  },\n  // @ts-ignore\n  toDOMStream: function toDOMStream(source, options) {\n    throw new Error(\"\\\"toDOMStream\\\" not available in this environment\");\n  },\n  // @ts-ignore\n  toNodeStream: function toNodeStream(source, options) {\n    throw new Error(\"\\\"toNodeStream\\\" not available in this environment\");\n  }\n};\n/** @ignore */\n\nvar pump = function pump(iterator) {\n  iterator.next();\n  return iterator;\n};\n/** @ignore */\n\n\nfunction _fromIterable(source) {\n  var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield, it, _ref, _yield$byteRange;\n\n  return _regeneratorRuntime().wrap(function _fromIterable$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          byteRange = function _byteRange() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n\n            var _joinUint8Arrays = joinUint8Arrays(buffers, size);\n\n            var _joinUint8Arrays2 = _slicedToArray(_joinUint8Arrays, 3);\n\n            buffer = _joinUint8Arrays2[0];\n            buffers = _joinUint8Arrays2[1];\n            bufferLength = _joinUint8Arrays2[2];\n            return buffer;\n          };\n\n          threw = false;\n          buffers = [];\n          bufferLength = 0;\n          _context.next = 6;\n          return null;\n\n        case 6:\n          _yield = _context.sent;\n          cmd = _yield.cmd;\n          size = _yield.size;\n          // initialize the iterator\n          it = toUint8ArrayIterator(source)[Symbol.iterator]();\n          _context.prev = 10;\n\n        case 11:\n          // read the next value\n          _ref = isNaN(size - bufferLength) ? it.next(undefined) : it.next(size - bufferLength);\n          done = _ref.done;\n          buffer = _ref.value;\n\n          // if chunk is not null or empty, push it onto the queue\n          if (!done && buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n          if (!(done || size <= bufferLength)) {\n            _context.next = 22;\n            break;\n          }\n\n        case 16:\n          _context.next = 18;\n          return byteRange();\n\n        case 18:\n          _yield$byteRange = _context.sent;\n          cmd = _yield$byteRange.cmd;\n          size = _yield$byteRange.size;\n\n        case 21:\n          if (size < bufferLength) {\n            _context.next = 16;\n            break;\n          }\n\n        case 22:\n          if (!done) {\n            _context.next = 11;\n            break;\n          }\n\n        case 23:\n          _context.next = 28;\n          break;\n\n        case 25:\n          _context.prev = 25;\n          _context.t0 = _context[\"catch\"](10);\n          (threw = true) && typeof it.throw === 'function' && it.throw(_context.t0);\n\n        case 28:\n          _context.prev = 28;\n          threw === false && typeof it.return === 'function' && it.return();\n          return _context.finish(28);\n\n        case 31:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[10, 25, 28, 31]]);\n}\n/** @ignore */\n\n\nfunction _fromAsyncIterable2(_x) {\n  return _fromAsyncIterable.apply(this, arguments);\n} // All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n\n/** @ignore */\n\n\nfunction _fromAsyncIterable() {\n  _fromAsyncIterable = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield2, it, _ref2, _yield$byteRange2;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            byteRange = function _byteRange2() {\n              if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n              }\n\n              var _joinUint8Arrays3 = joinUint8Arrays(buffers, size);\n\n              var _joinUint8Arrays4 = _slicedToArray(_joinUint8Arrays3, 3);\n\n              buffer = _joinUint8Arrays4[0];\n              buffers = _joinUint8Arrays4[1];\n              bufferLength = _joinUint8Arrays4[2];\n              return buffer;\n            };\n\n            threw = false;\n            buffers = [];\n            bufferLength = 0;\n            _context2.next = 6;\n            return null;\n\n          case 6:\n            _yield2 = _context2.sent;\n            cmd = _yield2.cmd;\n            size = _yield2.size;\n            // initialize the iterator\n            it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n            _context2.prev = 10;\n\n          case 11:\n            if (!isNaN(size - bufferLength)) {\n              _context2.next = 17;\n              break;\n            }\n\n            _context2.next = 14;\n            return _awaitAsyncGenerator(it.next(undefined));\n\n          case 14:\n            _context2.t0 = _context2.sent;\n            _context2.next = 20;\n            break;\n\n          case 17:\n            _context2.next = 19;\n            return _awaitAsyncGenerator(it.next(size - bufferLength));\n\n          case 19:\n            _context2.t0 = _context2.sent;\n\n          case 20:\n            _ref2 = _context2.t0;\n            done = _ref2.done;\n            buffer = _ref2.value;\n\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n              buffers.push(buffer);\n              bufferLength += buffer.byteLength;\n            } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n            if (!(done || size <= bufferLength)) {\n              _context2.next = 31;\n              break;\n            }\n\n          case 25:\n            _context2.next = 27;\n            return byteRange();\n\n          case 27:\n            _yield$byteRange2 = _context2.sent;\n            cmd = _yield$byteRange2.cmd;\n            size = _yield$byteRange2.size;\n\n          case 30:\n            if (size < bufferLength) {\n              _context2.next = 25;\n              break;\n            }\n\n          case 31:\n            if (!done) {\n              _context2.next = 11;\n              break;\n            }\n\n          case 32:\n            _context2.next = 40;\n            break;\n\n          case 34:\n            _context2.prev = 34;\n            _context2.t1 = _context2[\"catch\"](10);\n            _context2.t2 = (threw = true) && typeof it.throw === 'function';\n\n            if (!_context2.t2) {\n              _context2.next = 40;\n              break;\n            }\n\n            _context2.next = 40;\n            return _awaitAsyncGenerator(it.throw(_context2.t1));\n\n          case 40:\n            _context2.prev = 40;\n            _context2.t3 = threw === false && typeof it.return === 'function';\n\n            if (!_context2.t3) {\n              _context2.next = 45;\n              break;\n            }\n\n            _context2.next = 45;\n            return _awaitAsyncGenerator(it.return());\n\n          case 45:\n            return _context2.finish(40);\n\n          case 46:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, null, [[10, 34, 40, 46]]);\n  }));\n  return _fromAsyncIterable.apply(this, arguments);\n}\n\nfunction _fromDOMStream2(_x2) {\n  return _fromDOMStream.apply(this, arguments);\n}\n/** @ignore */\n\n\nfunction _fromDOMStream() {\n  _fromDOMStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield3, it, _ref3, _yield$byteRange3;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            byteRange = function _byteRange3() {\n              if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n              }\n\n              var _joinUint8Arrays5 = joinUint8Arrays(buffers, size);\n\n              var _joinUint8Arrays6 = _slicedToArray(_joinUint8Arrays5, 3);\n\n              buffer = _joinUint8Arrays6[0];\n              buffers = _joinUint8Arrays6[1];\n              bufferLength = _joinUint8Arrays6[2];\n              return buffer;\n            };\n\n            done = false, threw = false;\n            buffers = [];\n            bufferLength = 0;\n            _context3.next = 6;\n            return null;\n\n          case 6:\n            _yield3 = _context3.sent;\n            cmd = _yield3.cmd;\n            size = _yield3.size;\n            // initialize the reader and lock the stream\n            it = new AdaptiveByteReader(source);\n            _context3.prev = 10;\n\n          case 11:\n            if (!isNaN(size - bufferLength)) {\n              _context3.next = 17;\n              break;\n            }\n\n            _context3.next = 14;\n            return _awaitAsyncGenerator(it['read'](undefined));\n\n          case 14:\n            _context3.t0 = _context3.sent;\n            _context3.next = 20;\n            break;\n\n          case 17:\n            _context3.next = 19;\n            return _awaitAsyncGenerator(it['read'](size - bufferLength));\n\n          case 19:\n            _context3.t0 = _context3.sent;\n\n          case 20:\n            _ref3 = _context3.t0;\n            done = _ref3.done;\n            buffer = _ref3.value;\n\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n              buffers.push(toUint8Array(buffer));\n              bufferLength += buffer.byteLength;\n            } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n            if (!(done || size <= bufferLength)) {\n              _context3.next = 31;\n              break;\n            }\n\n          case 25:\n            _context3.next = 27;\n            return byteRange();\n\n          case 27:\n            _yield$byteRange3 = _context3.sent;\n            cmd = _yield$byteRange3.cmd;\n            size = _yield$byteRange3.size;\n\n          case 30:\n            if (size < bufferLength) {\n              _context3.next = 25;\n              break;\n            }\n\n          case 31:\n            if (!done) {\n              _context3.next = 11;\n              break;\n            }\n\n          case 32:\n            _context3.next = 40;\n            break;\n\n          case 34:\n            _context3.prev = 34;\n            _context3.t1 = _context3[\"catch\"](10);\n            _context3.t2 = threw = true;\n\n            if (!_context3.t2) {\n              _context3.next = 40;\n              break;\n            }\n\n            _context3.next = 40;\n            return _awaitAsyncGenerator(it['cancel'](_context3.t1));\n\n          case 40:\n            _context3.prev = 40;\n\n            if (!(threw === false)) {\n              _context3.next = 46;\n              break;\n            }\n\n            _context3.next = 44;\n            return _awaitAsyncGenerator(it['cancel']());\n\n          case 44:\n            _context3.next = 47;\n            break;\n\n          case 46:\n            source['locked'] && it.releaseLock();\n\n          case 47:\n            return _context3.finish(40);\n\n          case 48:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2, null, [[10, 34, 40, 48]]);\n  }));\n  return _fromDOMStream.apply(this, arguments);\n}\n\nvar AdaptiveByteReader = /*#__PURE__*/function () {\n  function AdaptiveByteReader(source) {\n    _classCallCheck(this, AdaptiveByteReader);\n\n    this.source = source;\n    this.byobReader = null;\n    this.defaultReader = null;\n\n    try {\n      this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n    } catch (e) {\n      this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n    }\n  }\n\n  _createClass(AdaptiveByteReader, [{\n    key: \"closed\",\n    get: function get() {\n      return this.reader ? this.reader['closed'].catch(function () {}) : Promise.resolve();\n    }\n  }, {\n    key: \"releaseLock\",\n    value: function releaseLock() {\n      if (this.reader) {\n        this.reader.releaseLock();\n      }\n\n      this.reader = this.byobReader = this.defaultReader = null;\n    }\n  }, {\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(reason) {\n        var reader, source;\n        return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                reader = this.reader, source = this.source;\n                _context4.t0 = reader;\n\n                if (!_context4.t0) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                _context4.next = 5;\n                return reader['cancel'](reason).catch(function () {});\n\n              case 5:\n                source && source['locked'] && this.releaseLock();\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function cancel(_x4) {\n        return _cancel.apply(this, arguments);\n      }\n\n      return cancel;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(size) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(size === 0)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", {\n                  done: this.reader == null,\n                  value: new Uint8Array(0)\n                });\n\n              case 2:\n                if (!(!this.supportsBYOB || typeof size !== 'number')) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                _context5.next = 5;\n                return this.getDefaultReader().read();\n\n              case 5:\n                _context5.t0 = _context5.sent;\n                _context5.next = 11;\n                break;\n\n              case 8:\n                _context5.next = 10;\n                return this.readFromBYOBReader(size);\n\n              case 10:\n                _context5.t0 = _context5.sent;\n\n              case 11:\n                result = _context5.t0;\n                !result.done && (result.value = toUint8Array(result));\n                return _context5.abrupt(\"return\", result);\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function read(_x5) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"getDefaultReader\",\n    value: function getDefaultReader() {\n      if (this.byobReader) {\n        this.releaseLock();\n      }\n\n      if (!this.defaultReader) {\n        this.defaultReader = this.source['getReader'](); // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n\n        this.defaultReader['closed'].catch(function () {});\n      }\n\n      return this.reader = this.defaultReader;\n    }\n  }, {\n    key: \"getBYOBReader\",\n    value: function getBYOBReader() {\n      if (this.defaultReader) {\n        this.releaseLock();\n      }\n\n      if (!this.byobReader) {\n        this.byobReader = this.source['getReader']({\n          mode: 'byob'\n        }); // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n\n        this.byobReader['closed'].catch(function () {});\n      }\n\n      return this.reader = this.byobReader;\n    } // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n\n  }, {\n    key: \"readFromBYOBReader\",\n    value: function () {\n      var _readFromBYOBReader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(size) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n\n              case 2:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function readFromBYOBReader(_x6) {\n        return _readFromBYOBReader.apply(this, arguments);\n      }\n\n      return readFromBYOBReader;\n    }()\n  }]);\n\n  return AdaptiveByteReader;\n}();\n/** @ignore */\n\n\nfunction readInto(_x7, _x8, _x9, _x10) {\n  return _readInto.apply(this, arguments);\n}\n/** @ignore */\n\n\nfunction _readInto() {\n  _readInto = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(reader, buffer, offset, size) {\n    var _yield$reader$read, done, value;\n\n    return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            if (!(offset >= size)) {\n              _context9.next = 2;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", {\n              done: false,\n              value: new Uint8Array(buffer, 0, size)\n            });\n\n          case 2:\n            _context9.next = 4;\n            return reader.read(new Uint8Array(buffer, offset, size - offset));\n\n          case 4:\n            _yield$reader$read = _context9.sent;\n            done = _yield$reader$read.done;\n            value = _yield$reader$read.value;\n\n            if (!((offset += value.byteLength) < size && !done)) {\n              _context9.next = 11;\n              break;\n            }\n\n            _context9.next = 10;\n            return readInto(reader, value.buffer, offset, size);\n\n          case 10:\n            return _context9.abrupt(\"return\", _context9.sent);\n\n          case 11:\n            return _context9.abrupt(\"return\", {\n              done: done,\n              value: new Uint8Array(value.buffer, 0, offset)\n            });\n\n          case 12:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _readInto.apply(this, arguments);\n}\n\nvar onEvent = function onEvent(stream, event) {\n  var handler = function handler(_) {\n    return resolve([event, _]);\n  };\n\n  var resolve;\n  return [event, handler, new Promise(function (r) {\n    return (resolve = r) && stream['once'](event, handler);\n  })];\n};\n/** @ignore */\n\n\nfunction _fromNodeStream2(_x3) {\n  return _fromNodeStream.apply(this, arguments);\n}\n\nfunction _fromNodeStream() {\n  _fromNodeStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(stream) {\n    var events, event, done, err, cmd, size, bufferLength, buffers, buffer, byteRange, _yield4, _yield$_awaitAsyncGen, _yield$_awaitAsyncGen2, _yield$byteRange4, cleanup;\n\n    return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            cleanup = function _cleanup(events, err) {\n              buffer = buffers = null;\n              return new Promise( /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(resolve, reject) {\n                  var _iterator, _step, _step$value, evt, fn, destroy;\n\n                  return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          _iterator = _createForOfIteratorHelper(events);\n\n                          try {\n                            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                              _step$value = _slicedToArray(_step.value, 2), evt = _step$value[0], fn = _step$value[1];\n                              stream['off'](evt, fn);\n                            }\n                          } catch (err) {\n                            _iterator.e(err);\n                          } finally {\n                            _iterator.f();\n                          }\n\n                          try {\n                            // Some stream implementations don't call the destroy callback,\n                            // because it's really a node-internal API. Just calling `destroy`\n                            // here should be enough to conform to the ReadableStream contract\n                            destroy = stream['destroy'];\n                            destroy && destroy.call(stream, err);\n                            err = undefined;\n                          } catch (e) {\n                            err = e || err;\n                          } finally {\n                            err != null ? reject(err) : resolve();\n                          }\n\n                        case 3:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _callee6);\n                }));\n\n                return function (_x11, _x12) {\n                  return _ref4.apply(this, arguments);\n                };\n              }());\n            };\n\n            byteRange = function _byteRange4() {\n              if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n              }\n\n              var _joinUint8Arrays7 = joinUint8Arrays(buffers, size);\n\n              var _joinUint8Arrays8 = _slicedToArray(_joinUint8Arrays7, 3);\n\n              buffer = _joinUint8Arrays8[0];\n              buffers = _joinUint8Arrays8[1];\n              bufferLength = _joinUint8Arrays8[2];\n              return buffer;\n            };\n\n            events = [];\n            event = 'error';\n            done = false, err = null;\n            bufferLength = 0;\n            buffers = [];\n            _context8.next = 9;\n            return null;\n\n          case 9:\n            _yield4 = _context8.sent;\n            cmd = _yield4.cmd;\n            size = _yield4.size;\n\n            if (!stream['isTTY']) {\n              _context8.next = 16;\n              break;\n            }\n\n            _context8.next = 15;\n            return new Uint8Array(0);\n\n          case 15:\n            return _context8.abrupt(\"return\", _context8.sent);\n\n          case 16:\n            _context8.prev = 16;\n            // initialize the stream event handlers\n            events[0] = onEvent(stream, 'end');\n            events[1] = onEvent(stream, 'error');\n\n          case 19:\n            events[2] = onEvent(stream, 'readable'); // wait on the first message event from the stream\n\n            _context8.next = 22;\n            return _awaitAsyncGenerator(Promise.race(events.map(function (x) {\n              return x[2];\n            })));\n\n          case 22:\n            _yield$_awaitAsyncGen = _context8.sent;\n            _yield$_awaitAsyncGen2 = _slicedToArray(_yield$_awaitAsyncGen, 2);\n            event = _yield$_awaitAsyncGen2[0];\n            err = _yield$_awaitAsyncGen2[1];\n\n            if (!(event === 'error')) {\n              _context8.next = 28;\n              break;\n            }\n\n            return _context8.abrupt(\"break\", 37);\n\n          case 28:\n            if (!(done = event === 'end')) {\n              // If the size is NaN, request to read everything in the stream's internal buffer\n              if (!isFinite(size - bufferLength)) {\n                buffer = toUint8Array(stream['read'](undefined));\n              } else {\n                buffer = toUint8Array(stream['read'](size - bufferLength)); // If the byteLength is 0, then the requested amount is more than the stream has\n                // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                // continue emitting readable events, so request to read everything the stream\n                // has in its internal buffer right now.\n\n                if (buffer.byteLength < size - bufferLength) {\n                  buffer = toUint8Array(stream['read'](undefined));\n                }\n              } // if chunk is not null or empty, push it onto the queue\n\n\n              if (buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n              }\n            } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n            if (!(done || size <= bufferLength)) {\n              _context8.next = 36;\n              break;\n            }\n\n          case 30:\n            _context8.next = 32;\n            return byteRange();\n\n          case 32:\n            _yield$byteRange4 = _context8.sent;\n            cmd = _yield$byteRange4.cmd;\n            size = _yield$byteRange4.size;\n\n          case 35:\n            if (size < bufferLength) {\n              _context8.next = 30;\n              break;\n            }\n\n          case 36:\n            if (!done) {\n              _context8.next = 19;\n              break;\n            }\n\n          case 37:\n            _context8.prev = 37;\n            _context8.next = 40;\n            return _awaitAsyncGenerator(cleanup(events, event === 'error' ? err : null));\n\n          case 40:\n            return _context8.finish(37);\n\n          case 41:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee7, null, [[16,, 37, 41]]);\n  }));\n  return _fromNodeStream.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["fromIterable","toUint8Array","joinUint8Arrays","toUint8ArrayIterator","toUint8ArrayAsyncIterator","source","pump","fromAsyncIterable","fromDOMStream","fromNodeStream","stream","toDOMStream","options","Error","toNodeStream","iterator","next","byteRange","cmd","buffers","size","buffer","bufferLength","threw","it","Symbol","isNaN","undefined","done","value","byteLength","push","throw","return","asyncIterator","AdaptiveByteReader","releaseLock","supportsBYOB","reader","getBYOBReader","e","getDefaultReader","catch","Promise","resolve","byobReader","defaultReader","reason","Uint8Array","read","readFromBYOBReader","result","mode","readInto","ArrayBuffer","offset","onEvent","event","handler","_","r","cleanup","events","err","reject","evt","fn","destroy","call","race","map","x","isFinite"],"sources":["io/adapters.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport {\n    toUint8Array,\n    joinUint8Arrays,\n    ArrayBufferViewInput,\n    toUint8ArrayIterator,\n    toUint8ArrayAsyncIterator\n} from '../util/buffer';\n\nimport { ReadableDOMStreamOptions } from './interfaces';\n\n/** @ignore */\nexport default {\n    fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n        return pump(fromIterable<T>(source));\n    },\n    fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromAsyncIterable<T>(source));\n    },\n    fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromDOMStream<T>(source));\n    },\n    fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: ReadableDOMStreamOptions): ReadableStream<T> {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: import('stream').ReadableOptions): import('stream').Readable {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n\n/** @ignore */\nconst pump = <T extends Iterator<any> | AsyncIterator<any>>(iterator: T) => { iterator.next(); return iterator; };\n\n/** @ignore */\nfunction* fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength) ?\n                it.next(undefined) : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return());\n    }\n}\n\n/** @ignore */\nasync function* fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it.next(undefined)\n                : await it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (await it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (await it.return());\n    }\n}\n\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nasync function* fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done = false, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the reader and lock the stream\n    let it = new AdaptiveByteReader(source);\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it['read'](undefined)\n                : await it['read'](size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(toUint8Array(buffer));\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (await it['cancel'](e));\n    } finally {\n        (threw === false) ? (await it['cancel']())\n            : source['locked'] && it.releaseLock();\n    }\n}\n\n/** @ignore */\nclass AdaptiveByteReader<T extends ArrayBufferViewInput> {\n\n    private supportsBYOB: boolean;\n    private byobReader: ReadableStreamBYOBReader | null = null;\n    private defaultReader: ReadableStreamDefaultReader<T> | null = null;\n    private reader: ReadableStreamBYOBReader | ReadableStreamDefaultReader<T> | null;\n\n    constructor(private source: ReadableStream<T>) {\n        try {\n            this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n        } catch (e) {\n            this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n        }\n    }\n\n    get closed(): Promise<void> {\n        return this.reader ? this.reader['closed'].catch(() => {}) : Promise.resolve();\n    }\n\n    releaseLock(): void {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = this.byobReader = this.defaultReader = null;\n    }\n\n    async cancel(reason?: any): Promise<void> {\n        const { reader, source } = this;\n        reader && (await reader['cancel'](reason).catch(() => {}));\n        source && (source['locked'] && this.releaseLock());\n    }\n\n    async read(size?: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n        if (size === 0) {\n            return { done: this.reader == null, value: new Uint8Array(0) };\n        }\n        const result = !this.supportsBYOB || typeof size !== 'number'\n            ? await this.getDefaultReader().read()\n            : await this.readFromBYOBReader(size);\n        !result.done && (result.value = toUint8Array(result as ReadableStreamReadResult<Uint8Array>));\n        return result as ReadableStreamReadResult<Uint8Array>;\n    }\n\n    private getDefaultReader() {\n        if (this.byobReader) { this.releaseLock(); }\n        if (!this.defaultReader) {\n            this.defaultReader = this.source['getReader']();\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.defaultReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.defaultReader);\n    }\n\n    private getBYOBReader() {\n        if (this.defaultReader) { this.releaseLock(); }\n        if (!this.byobReader) {\n            this.byobReader = this.source['getReader']({ mode: 'byob' });\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.byobReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.byobReader);\n    }\n\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n    private async readFromBYOBReader(size: number) {\n        return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n    }\n}\n\n/** @ignore */\nasync function readInto(reader: ReadableStreamBYOBReader, buffer: ArrayBufferLike, offset: number, size: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n    if (offset >= size) {\n        return { done: false, value: new Uint8Array(buffer, 0, size) };\n    }\n    const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));\n    if (((offset += value.byteLength) < size) && !done) {\n        return await readInto(reader, value.buffer, offset, size);\n    }\n    return { done, value: new Uint8Array(value.buffer, 0, offset) };\n}\n\n/** @ignore */\ntype EventName = 'end' | 'error' | 'readable';\n/** @ignore */\ntype Event = [EventName, (_: any) => void, Promise<[EventName, Error | null]>];\n/** @ignore */\nconst onEvent = <T extends string>(stream: NodeJS.ReadableStream, event: T) => {\n    let handler = (_: any) => resolve([event, _]);\n    let resolve: (value?: [T, any] | PromiseLike<[T, any]>) => void;\n    return [event, handler, new Promise<[T, any]>(\n        (r) => (resolve = r) && stream['once'](event, handler)\n    )] as Event;\n};\n\n/** @ignore */\nasync function* fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n\n    let events: Event[] = [];\n    let event: EventName = 'error';\n    let done = false, err: Error | null = null;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array | Buffer | string;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({ cmd, size } = yield <any> null);\n\n    // ignore stdin if it's a TTY\n    if ((stream as any)['isTTY']) { return yield new Uint8Array(0); }\n\n    try {\n        // initialize the stream event handlers\n        events[0] = onEvent(stream, 'end');\n        events[1] = onEvent(stream, 'error');\n\n        do {\n            events[2] = onEvent(stream, 'readable');\n\n            // wait on the first message event from the stream\n            [event, err] = await Promise.race(events.map((x) => x[2]));\n\n            // if the stream emitted an Error, rethrow it\n            if (event === 'error') { break; }\n            if (!(done = event === 'end')) {\n                // If the size is NaN, request to read everything in the stream's internal buffer\n                if (!isFinite(size - bufferLength)) {\n                    buffer = toUint8Array(stream['read'](undefined));\n                } else {\n                    buffer = toUint8Array(stream['read'](size - bufferLength));\n                    // If the byteLength is 0, then the requested amount is more than the stream has\n                    // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                    // continue emitting readable events, so request to read everything the stream\n                    // has in its internal buffer right now.\n                    if (buffer.byteLength < (size - bufferLength)) {\n                        buffer = toUint8Array(stream['read'](undefined));\n                    }\n                }\n                // if chunk is not null or empty, push it onto the queue\n                if (buffer.byteLength > 0) {\n                    buffers.push(buffer);\n                    bufferLength += buffer.byteLength;\n                }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } finally {\n        await cleanup(events, event === 'error' ? err : null);\n    }\n\n    function cleanup<T extends Error | null | void>(events: Event[], err?: T) {\n        buffer = buffers = <any> null;\n        return new Promise<T>(async (resolve, reject) => {\n            for (const [evt, fn] of events) {\n                stream['off'](evt, fn);\n            }\n            try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                const destroy = (stream as any)['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n            } catch (e) { err = e || err; } finally {\n                err != null ? reject(err) : resolve();\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}