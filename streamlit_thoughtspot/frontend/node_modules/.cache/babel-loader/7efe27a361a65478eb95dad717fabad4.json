{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _get from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _awaitAsyncGenerator from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/nathan.schroeder/Documents/dev/template/thoughtspot_component/frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\n\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from './vector';\nimport { BufferType } from './enum';\nimport { Data } from './data';\nimport { createIsValidFunction } from './builder/valid';\nimport { BitmapBufferBuilder, DataBufferBuilder, OffsetsBufferBuilder } from './builder/buffer';\nimport { strideForType } from './type';\n/**\n * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.\n *\n * A `Builder` is responsible for writing arbitrary JavaScript values\n * to ArrayBuffers and/or child Builders according to the Arrow specification\n * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.\n *\n * The `Builder` for each Arrow `DataType` handles converting and appending\n * values for a given `DataType`. The high-level {@link Builder.new `Builder.new()`} convenience\n * method creates the specific `Builder` subclass for the supplied `DataType`.\n *\n * Once created, `Builder` instances support both appending values to the end\n * of the `Builder`, and random-access writes to specific indices\n * (`Builder.prototype.append(value)` is a convenience method for\n * `builder.set(builder.length, value)`). Appending or setting values beyond the\n * Builder's current length may cause the builder to grow its underlying buffers\n * or child Builders (if applicable) to accommodate the new values.\n *\n * After enough values have been written to a `Builder`, `Builder.prototype.flush()`\n * will commit the values to the underlying ArrayBuffers (or child Builders). The\n * internal Builder state will be reset, and an instance of `Data<T>` is returned.\n * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return\n * an instance of `Vector<T>` instead.\n *\n * When there are no more values to write, use `Builder.prototype.finish()` to\n * finalize the `Builder`. This does not reset the internal state, so it is\n * necessary to call `Builder.prototype.flush()` or `toVector()` one last time\n * if there are still values queued to be flushed.\n *\n * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,\n * because this is when it flushes the values that have been enqueued in its internal\n * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.\n *\n * ```ts\n * import { Builder, Utf8 } from 'apache-arrow';\n *\n * const utf8Builder = Builder.new({\n *     type: new Utf8(),\n *     nullValues: [null, 'n/a']\n * });\n *\n * utf8Builder\n *     .append('hello')\n *     .append('n/a')\n *     .append('world')\n *     .append(null);\n *\n * const utf8Vector = utf8Builder.finish().toVector();\n *\n * console.log(utf8Vector.toJSON());\n * // > [\"hello\", null, \"world\", null]\n * ```\n *\n * @typeparam T The `DataType` of this `Builder`.\n * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n */\n\nexport var Builder = /*#__PURE__*/function () {\n  /**\n   * Construct a builder with the given Arrow DataType with optional null values,\n   * which will be interpreted as \"null\" when set or appended to the `Builder`.\n   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\n   */\n  function Builder(_ref2) {\n    var type = _ref2['type'],\n        nulls = _ref2['nullValues'];\n\n    _classCallCheck(this, Builder);\n\n    /**\n     * The number of values written to the `Builder` that haven't been flushed yet.\n     * @readonly\n     */\n    this.length = 0;\n    /**\n     * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.\n     * @readonly\n     */\n\n    this.finished = false;\n    this.type = type;\n    this.children = [];\n    this.nullValues = nulls;\n    this.stride = strideForType(type);\n    this._nulls = new BitmapBufferBuilder();\n\n    if (nulls && nulls.length > 0) {\n      this._isValid = createIsValidFunction(nulls);\n    }\n  }\n  /**\n   * Create a `Builder` instance based on the `type` property of the supplied `options` object.\n   * @param {BuilderOptions<T, TNull>} options An object with a required `DataType` instance\n   * and other optional parameters to be passed to the `Builder` subclass for the given `type`.\n   *\n   * @typeparam T The `DataType` of the `Builder` to create.\n   * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n   * @nocollapse\n   */\n  // @ts-ignore\n\n\n  _createClass(Builder, [{\n    key: \"toVector\",\n    value:\n    /**\n     * Flush the `Builder` and return a `Vector<T>`.\n     * @returns {Vector<T>} A `Vector<T>` of the flushed values.\n     */\n    function toVector() {\n      return Vector.new(this.flush());\n    }\n  }, {\n    key: \"ArrayType\",\n    get: function get() {\n      return this.type.ArrayType;\n    }\n  }, {\n    key: \"nullCount\",\n    get: function get() {\n      return this._nulls.numInvalid;\n    }\n  }, {\n    key: \"numChildren\",\n    get: function get() {\n      return this.children.length;\n    }\n    /**\n     * @returns The aggregate length (in bytes) of the values that have been written.\n     */\n\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      var size = 0;\n      this._offsets && (size += this._offsets.byteLength);\n      this._values && (size += this._values.byteLength);\n      this._nulls && (size += this._nulls.byteLength);\n      this._typeIds && (size += this._typeIds.byteLength);\n      return this.children.reduce(function (size, child) {\n        return size + child.byteLength;\n      }, size);\n    }\n    /**\n     * @returns The aggregate number of rows that have been reserved to write new values.\n     */\n\n  }, {\n    key: \"reservedLength\",\n    get: function get() {\n      return this._nulls.reservedLength;\n    }\n    /**\n     * @returns The aggregate length (in bytes) that has been reserved to write new values.\n     */\n\n  }, {\n    key: \"reservedByteLength\",\n    get: function get() {\n      var size = 0;\n      this._offsets && (size += this._offsets.reservedByteLength);\n      this._values && (size += this._values.reservedByteLength);\n      this._nulls && (size += this._nulls.reservedByteLength);\n      this._typeIds && (size += this._typeIds.reservedByteLength);\n      return this.children.reduce(function (size, child) {\n        return size + child.reservedByteLength;\n      }, size);\n    }\n  }, {\n    key: \"valueOffsets\",\n    get: function get() {\n      return this._offsets ? this._offsets.buffer : null;\n    }\n  }, {\n    key: \"values\",\n    get: function get() {\n      return this._values ? this._values.buffer : null;\n    }\n  }, {\n    key: \"nullBitmap\",\n    get: function get() {\n      return this._nulls ? this._nulls.buffer : null;\n    }\n  }, {\n    key: \"typeIds\",\n    get: function get() {\n      return this._typeIds ? this._typeIds.buffer : null;\n    }\n    /**\n     * Appends a value (or null) to this `Builder`.\n     * This is equivalent to `builder.set(builder.length, value)`.\n     * @param {T['TValue'] | TNull } value The value to append.\n     */\n\n  }, {\n    key: \"append\",\n    value: function append(value) {\n      return this.set(this.length, value);\n    }\n    /**\n     * Validates whether a value is valid (true), or null (false)\n     * @param {T['TValue'] | TNull } value The value to compare against null the value representations\n     */\n    // @ts-ignore\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(value) {\n      return this._isValid(value);\n    }\n    /**\n     * Write a value (or null-value sentinel) at the supplied index.\n     * If the value matches one of the null-value representations, a 1-bit is\n     * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\n     * the null `BitmapBufferBuilder`, and the value is passed to\n     * `Builder.prototype.setValue()`.\n     * @param {number} index The index of the value to write.\n     * @param {T['TValue'] | TNull } value The value to write at the supplied index.\n     * @returns {this} The updated `Builder` instance.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(index, value) {\n      if (this.setValid(index, this.isValid(value))) {\n        this.setValue(index, value);\n      }\n\n      return this;\n    }\n    /**\n     * Write a value to the underlying buffers at the supplied index, bypassing\n     * the null-value check. This is a low-level method that\n     * @param {number} index\n     * @param {T['TValue'] | TNull } value\n     */\n    // @ts-ignore\n\n  }, {\n    key: \"setValue\",\n    value: function setValue(index, value) {\n      this._setValue(this, index, value);\n    }\n  }, {\n    key: \"setValid\",\n    value: function setValid(index, valid) {\n      this.length = this._nulls.set(index, +valid).length;\n      return valid;\n    } // @ts-ignore\n\n  }, {\n    key: \"addChild\",\n    value: function addChild(child) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\".concat(this.numChildren);\n      throw new Error(\"Cannot append children to non-nested type \\\"\".concat(this.type, \"\\\"\"));\n    }\n    /**\n     * Retrieve the child `Builder` at the supplied `index`, or null if no child\n     * exists at that index.\n     * @param {number} index The index of the child `Builder` to retrieve.\n     * @returns {Builder | null} The child Builder at the supplied index or null.\n     */\n\n  }, {\n    key: \"getChildAt\",\n    value: function getChildAt(index) {\n      return this.children[index] || null;\n    }\n    /**\n     * Commit all the values that have been written to their underlying\n     * ArrayBuffers, including any child Builders if applicable, and reset\n     * the internal `Builder` state.\n     * @returns A `Data<T>` of the buffers and childData representing the values written.\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var buffers = [];\n      var values = this._values;\n      var offsets = this._offsets;\n      var typeIds = this._typeIds;\n      var length = this.length,\n          nullCount = this.nullCount;\n\n      if (typeIds) {\n        /* Unions */\n        buffers[BufferType.TYPE] = typeIds.flush(length); // DenseUnions\n\n        offsets && (buffers[BufferType.OFFSET] = offsets.flush(length));\n      } else if (offsets) {\n        /* Variable-width primitives (Binary, Utf8) and Lists */\n        // Binary, Utf8\n        values && (buffers[BufferType.DATA] = values.flush(offsets.last()));\n        buffers[BufferType.OFFSET] = offsets.flush(length);\n      } else if (values) {\n        /* Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, and Interval) */\n        buffers[BufferType.DATA] = values.flush(length);\n      }\n\n      nullCount > 0 && (buffers[BufferType.VALIDITY] = this._nulls.flush(length));\n      var data = Data.new(this.type, 0, length, nullCount, buffers, this.children.map(function (child) {\n        return child.flush();\n      }));\n      this.clear();\n      return data;\n    }\n    /**\n     * Finalize this `Builder`, and child builders if applicable.\n     * @returns {this} The finalized `Builder` instance.\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.finished = true;\n      this.children.forEach(function (child) {\n        return child.finish();\n      });\n      return this;\n    }\n    /**\n     * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\n     * @returns {this} The cleared `Builder` instance.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.length = 0;\n      this._offsets && this._offsets.clear();\n      this._values && this._values.clear();\n      this._nulls && this._nulls.clear();\n      this._typeIds && this._typeIds.clear();\n      this.children.forEach(function (child) {\n        return child.clear();\n      });\n      return this;\n    }\n  }], [{\n    key: \"new\",\n    value: function _new(options) {}\n    /** @nocollapse */\n    // @ts-ignore\n\n  }, {\n    key: \"throughNode\",\n    value: function throughNode(options) {\n      throw new Error(\"\\\"throughNode\\\" not available in this environment\");\n    }\n    /** @nocollapse */\n    // @ts-ignore\n\n  }, {\n    key: \"throughDOM\",\n    value: function throughDOM(options) {\n      throw new Error(\"\\\"throughDOM\\\" not available in this environment\");\n    }\n    /**\n     * Transform a synchronous `Iterable` of arbitrary JavaScript values into a\n     * sequence of Arrow Vector<T> following the chunking semantics defined in\n     * the supplied `options` argument.\n     *\n     * This function returns a function that accepts an `Iterable` of values to\n     * transform. When called, this function returns an Iterator of `Vector<T>`.\n     *\n     * The resulting `Iterator<Vector<T>>` yields Vectors based on the\n     * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n     *\n     * * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\n     *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n     *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n     * * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\n     *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n     *   reaches or exceeds the supplied `highWaterMark`.\n     *\n     * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n     * @returns A function which accepts a JavaScript `Iterable` of values to\n     *          write, and returns an `Iterator` that yields Vectors according\n     *          to the chunking semantics defined in the `options` argument.\n     * @nocollapse\n     */\n\n  }, {\n    key: \"throughIterable\",\n    value: function throughIterable(options) {\n      return _throughIterable(options);\n    }\n    /**\n     * Transform an `AsyncIterable` of arbitrary JavaScript values into a\n     * sequence of Arrow Vector<T> following the chunking semantics defined in\n     * the supplied `options` argument.\n     *\n     * This function returns a function that accepts an `AsyncIterable` of values to\n     * transform. When called, this function returns an AsyncIterator of `Vector<T>`.\n     *\n     * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\n     * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n     *\n     * * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\n     *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n     *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n     * * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\n     *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n     *   reaches or exceeds the supplied `highWaterMark`.\n     *\n     * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n     * @returns A function which accepts a JavaScript `AsyncIterable` of values\n     *          to write, and returns an `AsyncIterator` that yields Vectors\n     *          according to the chunking semantics defined in the `options`\n     *          argument.\n     * @nocollapse\n     */\n\n  }, {\n    key: \"throughAsyncIterable\",\n    value: function throughAsyncIterable(options) {\n      return _throughAsyncIterable(options);\n    }\n  }]);\n\n  return Builder;\n}();\nBuilder.prototype.length = 1;\nBuilder.prototype.stride = 1;\nBuilder.prototype.children = null;\nBuilder.prototype.finished = false;\nBuilder.prototype.nullValues = null;\n\nBuilder.prototype._isValid = function () {\n  return true;\n};\n/** @ignore */\n\n\nexport var FixedWidthBuilder = /*#__PURE__*/function (_Builder) {\n  _inherits(FixedWidthBuilder, _Builder);\n\n  var _super = _createSuper(FixedWidthBuilder);\n\n  function FixedWidthBuilder(opts) {\n    var _this;\n\n    _classCallCheck(this, FixedWidthBuilder);\n\n    _this = _super.call(this, opts);\n    _this._values = new DataBufferBuilder(new _this.ArrayType(0), _this.stride);\n    return _this;\n  }\n\n  _createClass(FixedWidthBuilder, [{\n    key: \"setValue\",\n    value: function setValue(index, value) {\n      var values = this._values;\n      values.reserve(index - values.length + 1);\n      return _get(_getPrototypeOf(FixedWidthBuilder.prototype), \"setValue\", this).call(this, index, value);\n    }\n  }]);\n\n  return FixedWidthBuilder;\n}(Builder);\n/** @ignore */\n\nexport var VariableWidthBuilder = /*#__PURE__*/function (_Builder2) {\n  _inherits(VariableWidthBuilder, _Builder2);\n\n  var _super2 = _createSuper(VariableWidthBuilder);\n\n  function VariableWidthBuilder(opts) {\n    var _this2;\n\n    _classCallCheck(this, VariableWidthBuilder);\n\n    _this2 = _super2.call(this, opts);\n    _this2._pendingLength = 0;\n    _this2._offsets = new OffsetsBufferBuilder();\n    return _this2;\n  }\n\n  _createClass(VariableWidthBuilder, [{\n    key: \"setValue\",\n    value: function setValue(index, value) {\n      var pending = this._pending || (this._pending = new Map());\n      var current = pending.get(index);\n      current && (this._pendingLength -= current.length);\n      this._pendingLength += value.length;\n      pending.set(index, value);\n    }\n  }, {\n    key: \"setValid\",\n    value: function setValid(index, isValid) {\n      if (!_get(_getPrototypeOf(VariableWidthBuilder.prototype), \"setValid\", this).call(this, index, isValid)) {\n        (this._pending || (this._pending = new Map())).set(index, undefined);\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._pendingLength = 0;\n      this._pending = undefined;\n      return _get(_getPrototypeOf(VariableWidthBuilder.prototype), \"clear\", this).call(this);\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      this._flush();\n\n      return _get(_getPrototypeOf(VariableWidthBuilder.prototype), \"flush\", this).call(this);\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this._flush();\n\n      return _get(_getPrototypeOf(VariableWidthBuilder.prototype), \"finish\", this).call(this);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush() {\n      var pending = this._pending;\n      var pendingLength = this._pendingLength;\n      this._pendingLength = 0;\n      this._pending = undefined;\n\n      if (pending && pending.size > 0) {\n        this._flushPending(pending, pendingLength);\n      }\n\n      return this;\n    }\n  }]);\n\n  return VariableWidthBuilder;\n}(Builder);\n/** @ignore */\n\nfunction _throughIterable(options) {\n  var _options$queueingStra = options['queueingStrategy'],\n      queueingStrategy = _options$queueingStra === void 0 ? 'count' : _options$queueingStra;\n  var _options$highWaterMar = options['highWaterMark'],\n      highWaterMark = _options$highWaterMar === void 0 ? queueingStrategy !== 'bytes' ? 1000 : Math.pow(2, 14) : _options$highWaterMar;\n  var sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n    var numChunks, builder, _iterator2, _step2, value;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            numChunks = 0;\n            builder = Builder.new(options);\n            _iterator2 = _createForOfIteratorHelper(source);\n            _context.prev = 3;\n\n            _iterator2.s();\n\n          case 5:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 14;\n              break;\n            }\n\n            value = _step2.value;\n\n            if (!(builder.append(value)[sizeProperty] >= highWaterMark)) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.t0 = ++numChunks;\n\n            if (!_context.t0) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.next = 12;\n            return builder.toVector();\n\n          case 12:\n            _context.next = 5;\n            break;\n\n          case 14:\n            _context.next = 19;\n            break;\n\n          case 16:\n            _context.prev = 16;\n            _context.t1 = _context[\"catch\"](3);\n\n            _iterator2.e(_context.t1);\n\n          case 19:\n            _context.prev = 19;\n\n            _iterator2.f();\n\n            return _context.finish(19);\n\n          case 22:\n            if (!(builder.finish().length > 0 || numChunks === 0)) {\n              _context.next = 25;\n              break;\n            }\n\n            _context.next = 25;\n            return builder.toVector();\n\n          case 25:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 16, 19, 22]]);\n  });\n}\n/** @ignore */\n\n\nfunction _throughAsyncIterable(options) {\n  var _options$queueingStra2 = options['queueingStrategy'],\n      queueingStrategy = _options$queueingStra2 === void 0 ? 'count' : _options$queueingStra2;\n  var _options$highWaterMar2 = options['highWaterMark'],\n      highWaterMark = _options$highWaterMar2 === void 0 ? queueingStrategy !== 'bytes' ? 1000 : Math.pow(2, 14) : _options$highWaterMar2;\n  var sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n  return /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n      var numChunks, builder, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, value;\n\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              numChunks = 0;\n              builder = Builder.new(options);\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context2.prev = 4;\n              _iterator = _asyncIterator(source);\n\n            case 6:\n              _context2.next = 8;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 8:\n              if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n                _context2.next = 18;\n                break;\n              }\n\n              value = _step.value;\n\n              if (!(builder.append(value)[sizeProperty] >= highWaterMark)) {\n                _context2.next = 15;\n                break;\n              }\n\n              _context2.t0 = ++numChunks;\n\n              if (!_context2.t0) {\n                _context2.next = 15;\n                break;\n              }\n\n              _context2.next = 15;\n              return builder.toVector();\n\n            case 15:\n              _iteratorAbruptCompletion = false;\n              _context2.next = 6;\n              break;\n\n            case 18:\n              _context2.next = 24;\n              break;\n\n            case 20:\n              _context2.prev = 20;\n              _context2.t1 = _context2[\"catch\"](4);\n              _didIteratorError = true;\n              _iteratorError = _context2.t1;\n\n            case 24:\n              _context2.prev = 24;\n              _context2.prev = 25;\n\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context2.next = 29;\n                break;\n              }\n\n              _context2.next = 29;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 29:\n              _context2.prev = 29;\n\n              if (!_didIteratorError) {\n                _context2.next = 32;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 32:\n              return _context2.finish(29);\n\n            case 33:\n              return _context2.finish(24);\n\n            case 34:\n              if (!(builder.finish().length > 0 || numChunks === 0)) {\n                _context2.next = 37;\n                break;\n              }\n\n              _context2.next = 37;\n              return builder.toVector();\n\n            case 37:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[4, 20, 24, 34], [25,, 29, 33]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"mappings":"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","names":["Vector","BufferType","Data","createIsValidFunction","BitmapBufferBuilder","DataBufferBuilder","OffsetsBufferBuilder","strideForType","Builder","type","nulls","children","nullValues","stride","_nulls","length","_isValid","new","flush","ArrayType","numInvalid","size","_offsets","byteLength","_values","_typeIds","reduce","child","reservedLength","reservedByteLength","buffer","value","set","index","setValid","isValid","setValue","_setValue","valid","name","numChildren","Error","buffers","values","offsets","typeIds","nullCount","TYPE","OFFSET","DATA","last","VALIDITY","data","map","clear","finished","forEach","finish","options","throughIterable","throughAsyncIterable","prototype","FixedWidthBuilder","opts","reserve","VariableWidthBuilder","pending","_pending","Map","current","get","_pendingLength","undefined","_flush","pendingLength","_flushPending","queueingStrategy","highWaterMark","sizeProperty","source","numChunks","builder","append","toVector"],"sources":["builder.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from './vector';\nimport { BufferType } from './enum';\nimport { Data, Buffers } from './data';\nimport { createIsValidFunction } from './builder/valid';\nimport { BuilderType as B, VectorType as V} from './interfaces';\nimport { BufferBuilder, BitmapBufferBuilder, DataBufferBuilder, OffsetsBufferBuilder } from './builder/buffer';\nimport {\n    DataType, strideForType,\n    Float, Int, Decimal, FixedSizeBinary,\n    Date_, Time, Timestamp, Interval,\n    Utf8, Binary, List, Map_\n} from './type';\n\n/**\n * A set of options required to create a `Builder` instance for a given `DataType`.\n * @see {@link Builder}\n */\nexport interface BuilderOptions<T extends DataType = any, TNull = any> {\n    type: T;\n    nullValues?: TNull[] | ReadonlyArray<TNull> | null;\n    children?: { [key: string]: BuilderOptions; } | BuilderOptions[];\n}\n\n/**\n * A set of options to create an Iterable or AsyncIterable `Builder` transform function.\n * @see {@link Builder.throughIterable}\n * @see {@link Builder.throughAsyncIterable}\n */\n\nexport interface IterableBuilderOptions<T extends DataType = any, TNull = any> extends BuilderOptions<T, TNull> {\n    highWaterMark?: number;\n    queueingStrategy?: 'bytes' | 'count';\n    dictionaryHashFunction?: (value: any) => string | number;\n    valueToChildTypeId?: (builder: Builder<T, TNull>, value: any, offset: number) => number;\n}\n\n/**\n * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.\n *\n * A `Builder` is responsible for writing arbitrary JavaScript values\n * to ArrayBuffers and/or child Builders according to the Arrow specification\n * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.\n *\n * The `Builder` for each Arrow `DataType` handles converting and appending\n * values for a given `DataType`. The high-level {@link Builder.new `Builder.new()`} convenience\n * method creates the specific `Builder` subclass for the supplied `DataType`.\n *\n * Once created, `Builder` instances support both appending values to the end\n * of the `Builder`, and random-access writes to specific indices\n * (`Builder.prototype.append(value)` is a convenience method for\n * `builder.set(builder.length, value)`). Appending or setting values beyond the\n * Builder's current length may cause the builder to grow its underlying buffers\n * or child Builders (if applicable) to accommodate the new values.\n *\n * After enough values have been written to a `Builder`, `Builder.prototype.flush()`\n * will commit the values to the underlying ArrayBuffers (or child Builders). The\n * internal Builder state will be reset, and an instance of `Data<T>` is returned.\n * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return\n * an instance of `Vector<T>` instead.\n *\n * When there are no more values to write, use `Builder.prototype.finish()` to\n * finalize the `Builder`. This does not reset the internal state, so it is\n * necessary to call `Builder.prototype.flush()` or `toVector()` one last time\n * if there are still values queued to be flushed.\n *\n * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,\n * because this is when it flushes the values that have been enqueued in its internal\n * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.\n *\n * ```ts\n * import { Builder, Utf8 } from 'apache-arrow';\n *\n * const utf8Builder = Builder.new({\n *     type: new Utf8(),\n *     nullValues: [null, 'n/a']\n * });\n *\n * utf8Builder\n *     .append('hello')\n *     .append('n/a')\n *     .append('world')\n *     .append(null);\n *\n * const utf8Vector = utf8Builder.finish().toVector();\n *\n * console.log(utf8Vector.toJSON());\n * // > [\"hello\", null, \"world\", null]\n * ```\n *\n * @typeparam T The `DataType` of this `Builder`.\n * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n */\nexport abstract class Builder<T extends DataType = any, TNull = any> {\n\n    /**\n     * Create a `Builder` instance based on the `type` property of the supplied `options` object.\n     * @param {BuilderOptions<T, TNull>} options An object with a required `DataType` instance\n     * and other optional parameters to be passed to the `Builder` subclass for the given `type`.\n     *\n     * @typeparam T The `DataType` of the `Builder` to create.\n     * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n     * @nocollapse\n     */\n    // @ts-ignore\n    public static new<T extends DataType = any, TNull = any>(options: BuilderOptions<T, TNull>): B<T, TNull> {}\n\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughNode<T extends DataType = any, TNull = any>(options: import('./io/node/builder').BuilderDuplexOptions<T, TNull>): import('stream').Duplex {\n        throw new Error(`\"throughNode\" not available in this environment`);\n    }\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughDOM<T extends DataType = any, TNull = any>(options: import('./io/whatwg/builder').BuilderTransformOptions<T, TNull>): import('./io/whatwg/builder').BuilderTransform<T, TNull> {\n        throw new Error(`\"throughDOM\" not available in this environment`);\n    }\n\n    /**\n     * Transform a synchronous `Iterable` of arbitrary JavaScript values into a\n     * sequence of Arrow Vector<T> following the chunking semantics defined in\n     * the supplied `options` argument.\n     *\n     * This function returns a function that accepts an `Iterable` of values to\n     * transform. When called, this function returns an Iterator of `Vector<T>`.\n     *\n     * The resulting `Iterator<Vector<T>>` yields Vectors based on the\n     * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n     *\n     * * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\n     *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n     *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n     * * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\n     *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n     *   reaches or exceeds the supplied `highWaterMark`.\n     *\n     * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n     * @returns A function which accepts a JavaScript `Iterable` of values to\n     *          write, and returns an `Iterator` that yields Vectors according\n     *          to the chunking semantics defined in the `options` argument.\n     * @nocollapse\n     */\n    public static throughIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\n        return throughIterable(options);\n    }\n\n    /**\n     * Transform an `AsyncIterable` of arbitrary JavaScript values into a\n     * sequence of Arrow Vector<T> following the chunking semantics defined in\n     * the supplied `options` argument.\n     *\n     * This function returns a function that accepts an `AsyncIterable` of values to\n     * transform. When called, this function returns an AsyncIterator of `Vector<T>`.\n     *\n     * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\n     * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n     *\n     * * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\n     *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n     *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n     * * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\n     *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n     *   reaches or exceeds the supplied `highWaterMark`.\n     *\n     * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n     * @returns A function which accepts a JavaScript `AsyncIterable` of values\n     *          to write, and returns an `AsyncIterator` that yields Vectors\n     *          according to the chunking semantics defined in the `options`\n     *          argument.\n     * @nocollapse\n     */\n    public static throughAsyncIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\n        return throughAsyncIterable(options);\n    }\n\n    /**\n     * Construct a builder with the given Arrow DataType with optional null values,\n     * which will be interpreted as \"null\" when set or appended to the `Builder`.\n     * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\n     */\n    constructor({ 'type': type, 'nullValues': nulls }: BuilderOptions<T, TNull>) {\n        this.type = type;\n        this.children = [];\n        this.nullValues = nulls;\n        this.stride = strideForType(type);\n        this._nulls = new BitmapBufferBuilder();\n        if (nulls && nulls.length > 0) {\n            this._isValid = createIsValidFunction(nulls);\n        }\n    }\n\n    /**\n     * The Builder's `DataType` instance.\n     * @readonly\n     */\n    public type: T;\n    /**\n     * The number of values written to the `Builder` that haven't been flushed yet.\n     * @readonly\n     */\n    public length = 0;\n    /**\n     * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.\n     * @readonly\n     */\n    public finished = false;\n    /**\n     * The number of elements in the underlying values TypedArray that\n     * represent a single logical element, determined by this Builder's\n     * `DataType`. This is 1 for most types, but is larger when the `DataType`\n     * is `Int64`, `Uint64`, `Decimal`, `DateMillisecond`, certain variants of\n     * `Interval`, `Time`, or `Timestamp`, `FixedSizeBinary`, and `FixedSizeList`.\n     * @readonly\n     */\n    public readonly stride: number;\n    public readonly children: Builder[];\n    /**\n     * The list of null-value sentinels for this `Builder`. When one of these values\n     * is written to the `Builder` (either via `Builder.prototype.set()` or `Builder.prototype.append()`),\n     * a 1-bit is written to this Builder's underlying null BitmapBufferBuilder.\n     * @readonly\n     */\n    public readonly nullValues?: TNull[] | ReadonlyArray<TNull> | null;\n\n    /**\n     * Flush the `Builder` and return a `Vector<T>`.\n     * @returns {Vector<T>} A `Vector<T>` of the flushed values.\n     */\n    public toVector() { return Vector.new(this.flush()); }\n\n    public get ArrayType() { return this.type.ArrayType; }\n    public get nullCount() { return this._nulls.numInvalid; }\n    public get numChildren() { return this.children.length; }\n\n    /**\n     * @returns The aggregate length (in bytes) of the values that have been written.\n     */\n    public get byteLength(): number {\n        let size = 0;\n        this._offsets && (size += this._offsets.byteLength);\n        this._values && (size += this._values.byteLength);\n        this._nulls && (size += this._nulls.byteLength);\n        this._typeIds && (size += this._typeIds.byteLength);\n        return this.children.reduce((size, child) => size + child.byteLength, size);\n    }\n\n    /**\n     * @returns The aggregate number of rows that have been reserved to write new values.\n     */\n    public get reservedLength(): number {\n        return this._nulls.reservedLength;\n    }\n\n    /**\n     * @returns The aggregate length (in bytes) that has been reserved to write new values.\n     */\n    public get reservedByteLength(): number {\n        let size = 0;\n        this._offsets && (size += this._offsets.reservedByteLength);\n        this._values && (size += this._values.reservedByteLength);\n        this._nulls && (size += this._nulls.reservedByteLength);\n        this._typeIds && (size += this._typeIds.reservedByteLength);\n        return this.children.reduce((size, child) => size + child.reservedByteLength, size);\n    }\n\n    // @ts-ignore\n    protected _offsets: DataBufferBuilder<Int32Array>;\n    public get valueOffsets() { return this._offsets ? this._offsets.buffer : null; }\n\n    // @ts-ignore\n    protected _values: BufferBuilder<T['TArray'], any>;\n    public get values() { return this._values ? this._values.buffer : null; }\n\n    protected _nulls: BitmapBufferBuilder;\n    public get nullBitmap() { return this._nulls ? this._nulls.buffer : null; }\n\n    // @ts-ignore\n    protected _typeIds: DataBufferBuilder<Int8Array>;\n    public get typeIds() { return this._typeIds ? this._typeIds.buffer : null; }\n\n    // @ts-ignore\n    protected _isValid: (value: T['TValue'] | TNull) => boolean;\n    // @ts-ignore\n    protected _setValue: (inst: Builder<T>, index: number, value: T['TValue']) => void;\n\n    /**\n     * Appends a value (or null) to this `Builder`.\n     * This is equivalent to `builder.set(builder.length, value)`.\n     * @param {T['TValue'] | TNull } value The value to append.\n     */\n    public append(value: T['TValue'] | TNull) { return this.set(this.length, value); }\n\n    /**\n     * Validates whether a value is valid (true), or null (false)\n     * @param {T['TValue'] | TNull } value The value to compare against null the value representations\n     */\n    // @ts-ignore\n    public isValid(value: T['TValue'] | TNull): boolean { return this._isValid(value); }\n\n    /**\n     * Write a value (or null-value sentinel) at the supplied index.\n     * If the value matches one of the null-value representations, a 1-bit is\n     * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\n     * the null `BitmapBufferBuilder`, and the value is passed to\n     * `Builder.prototype.setValue()`.\n     * @param {number} index The index of the value to write.\n     * @param {T['TValue'] | TNull } value The value to write at the supplied index.\n     * @returns {this} The updated `Builder` instance.\n     */\n    public set(index: number, value: T['TValue'] | TNull) {\n        if (this.setValid(index, this.isValid(value))) {\n            this.setValue(index, value);\n        }\n        return this;\n    }\n\n    /**\n     * Write a value to the underlying buffers at the supplied index, bypassing\n     * the null-value check. This is a low-level method that\n     * @param {number} index\n     * @param {T['TValue'] | TNull } value\n     */\n    // @ts-ignore\n    public setValue(index: number, value: T['TValue']) { this._setValue(this, index, value); }\n    public setValid(index: number, valid: boolean) {\n        this.length = this._nulls.set(index, +valid).length;\n        return valid;\n    }\n\n    // @ts-ignore\n    public addChild(child: Builder, name = `${this.numChildren}`) {\n        throw new Error(`Cannot append children to non-nested type \"${this.type}\"`);\n    }\n\n    /**\n     * Retrieve the child `Builder` at the supplied `index`, or null if no child\n     * exists at that index.\n     * @param {number} index The index of the child `Builder` to retrieve.\n     * @returns {Builder | null} The child Builder at the supplied index or null.\n     */\n    public getChildAt<R extends DataType = any>(index: number): Builder<R> | null {\n        return this.children[index] || null;\n    }\n\n    /**\n     * Commit all the values that have been written to their underlying\n     * ArrayBuffers, including any child Builders if applicable, and reset\n     * the internal `Builder` state.\n     * @returns A `Data<T>` of the buffers and childData representing the values written.\n     */\n    public flush() {\n\n        const buffers: any = [];\n        const values =  this._values;\n        const offsets =  this._offsets;\n        const typeIds =  this._typeIds;\n        const { length, nullCount } = this;\n\n        if (typeIds) { /* Unions */\n            buffers[BufferType.TYPE] = typeIds.flush(length);\n            // DenseUnions\n            offsets && (buffers[BufferType.OFFSET] = offsets.flush(length));\n        } else if (offsets) { /* Variable-width primitives (Binary, Utf8) and Lists */\n            // Binary, Utf8\n            values && (buffers[BufferType.DATA] = values.flush(offsets.last()));\n            buffers[BufferType.OFFSET] = offsets.flush(length);\n        } else if (values) { /* Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, and Interval) */\n            buffers[BufferType.DATA] = values.flush(length);\n        }\n\n        nullCount > 0 && (buffers[BufferType.VALIDITY] = this._nulls.flush(length));\n\n        const data = Data.new<T>(\n            this.type, 0, length, nullCount, buffers as Buffers<T>,\n            this.children.map((child) => child.flush())) as Data<T>;\n\n        this.clear();\n\n        return data;\n    }\n\n    /**\n     * Finalize this `Builder`, and child builders if applicable.\n     * @returns {this} The finalized `Builder` instance.\n     */\n    public finish() {\n        this.finished = true;\n        this.children.forEach((child) => child.finish());\n        return this;\n    }\n\n    /**\n     * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\n     * @returns {this} The cleared `Builder` instance.\n     */\n    public clear() {\n        this.length = 0;\n        this._offsets && (this._offsets.clear());\n        this._values && (this._values.clear());\n        this._nulls && (this._nulls.clear());\n        this._typeIds && (this._typeIds.clear());\n        this.children.forEach((child) => child.clear());\n        return this;\n    }\n}\n\n(Builder.prototype as any).length = 1;\n(Builder.prototype as any).stride = 1;\n(Builder.prototype as any).children = null;\n(Builder.prototype as any).finished = false;\n(Builder.prototype as any).nullValues = null;\n(Builder.prototype as any)._isValid = () => true;\n\n/** @ignore */\nexport abstract class FixedWidthBuilder<T extends Int | Float | FixedSizeBinary | Date_ | Timestamp | Time | Decimal | Interval = any, TNull = any> extends Builder<T, TNull> {\n    constructor(opts: BuilderOptions<T, TNull>) {\n        super(opts);\n        this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);\n    }\n    public setValue(index: number, value: T['TValue']) {\n        const values = this._values;\n        values.reserve(index - values.length + 1);\n        return super.setValue(index, value);\n    }\n}\n\n/** @ignore */\nexport abstract class VariableWidthBuilder<T extends Binary | Utf8 | List | Map_, TNull = any> extends Builder<T, TNull> {\n    protected _pendingLength: number = 0;\n    protected _offsets: OffsetsBufferBuilder;\n    protected _pending: Map<number, any> | undefined;\n    constructor(opts: BuilderOptions<T, TNull>) {\n        super(opts);\n        this._offsets = new OffsetsBufferBuilder();\n    }\n    public setValue(index: number, value: T['TValue']) {\n        const pending = this._pending || (this._pending = new Map());\n        const current = pending.get(index);\n        current && (this._pendingLength -= current.length);\n        this._pendingLength += value.length;\n        pending.set(index, value);\n    }\n    public setValid(index: number, isValid: boolean) {\n        if (!super.setValid(index, isValid)) {\n            (this._pending || (this._pending = new Map())).set(index, undefined);\n            return false;\n        }\n        return true;\n    }\n    public clear() {\n        this._pendingLength = 0;\n        this._pending = undefined;\n        return super.clear();\n    }\n    public flush() {\n        this._flush();\n        return super.flush();\n    }\n    public finish() {\n        this._flush();\n        return super.finish();\n    }\n    protected _flush() {\n        const pending = this._pending;\n        const pendingLength = this._pendingLength;\n        this._pendingLength = 0;\n        this._pending = undefined;\n        if (pending && pending.size > 0) {\n            this._flushPending(pending, pendingLength);\n        }\n        return this;\n    }\n    protected abstract _flushPending(pending: Map<number, any>, pendingLength: number): void;\n}\n\n/** @ignore */\ntype ThroughIterable<T extends DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull>) => IterableIterator<V<T>>;\n\n/** @ignore */\nfunction throughIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>): ThroughIterable<T, TNull> {\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? 1000 : 2 ** 14 } = options;\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n    return function*(source: Iterable<T['TValue'] | TNull>) {\n        let numChunks = 0;\n        let builder = Builder.new(options);\n        for (const value of source) {\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\n                ++numChunks && (yield builder.toVector());\n            }\n        }\n        if (builder.finish().length > 0 || numChunks === 0) {\n            yield builder.toVector();\n        }\n    };\n}\n\n/** @ignore */\ntype ThroughAsyncIterable<T extends DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) => AsyncIterableIterator<V<T>>;\n\n/** @ignore */\nfunction throughAsyncIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>): ThroughAsyncIterable<T, TNull> {\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? 1000 : 2 ** 14 } = options;\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n    return async function* (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) {\n        let numChunks = 0;\n        let builder = Builder.new(options);\n        for await (const value of source) {\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\n                ++numChunks && (yield builder.toVector());\n            }\n        }\n        if (builder.finish().length > 0 || numChunks === 0) {\n            yield builder.toVector();\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}