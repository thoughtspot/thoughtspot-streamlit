{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Data } from '../data';\nimport { Field } from '../schema';\nimport { Column } from '../column';\nimport { Vector } from '../vector';\nimport { DataType } from '../type';\nimport { Chunked } from '../vector/chunked';\nconst isArray = Array.isArray;\n/** @ignore */\n\nexport const selectArgs = (Ctor, vals) => _selectArgs(Ctor, vals, [], 0);\n/** @ignore */\n\nexport const selectColumnArgs = args => {\n  const [fields, values] = _selectFieldArgs(args, [[], []]);\n\n  return values.map((x, i) => x instanceof Column ? Column.new(x.field.clone(fields[i]), x) : x instanceof Vector ? Column.new(fields[i], x) : Column.new(fields[i], []));\n};\n/** @ignore */\n\nexport const selectFieldArgs = args => _selectFieldArgs(args, [[], []]);\n/** @ignore */\n\nexport const selectChunkArgs = (Ctor, vals) => _selectChunkArgs(Ctor, vals, [], 0);\n/** @ignore */\n\nexport const selectVectorChildrenArgs = (Ctor, vals) => _selectVectorChildrenArgs(Ctor, vals, [], 0);\n/** @ignore */\n\nexport const selectColumnChildrenArgs = (Ctor, vals) => _selectColumnChildrenArgs(Ctor, vals, [], 0);\n/** @ignore */\n\nfunction _selectArgs(Ctor, vals, res, idx) {\n  let value,\n      j = idx;\n  let i = -1,\n      n = vals.length;\n\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Ctor) {\n      res[j++] = value;\n    }\n  }\n\n  return res;\n}\n/** @ignore */\n\n\nfunction _selectChunkArgs(Ctor, vals, res, idx) {\n  let value,\n      j = idx;\n  let i = -1,\n      n = vals.length;\n\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectChunkArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Chunked) {\n      j = _selectChunkArgs(Ctor, value.chunks, res, j).length;\n    } else if (value instanceof Ctor) {\n      res[j++] = value;\n    }\n  }\n\n  return res;\n}\n/** @ignore */\n\n\nfunction _selectVectorChildrenArgs(Ctor, vals, res, idx) {\n  let value,\n      j = idx;\n  let i = -1,\n      n = vals.length;\n\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectVectorChildrenArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Ctor) {\n      j = _selectArgs(Vector, value.schema.fields.map((_, i) => value.getChildAt(i)), res, j).length;\n    } else if (value instanceof Vector) {\n      res[j++] = value;\n    }\n  }\n\n  return res;\n}\n/** @ignore */\n\n\nfunction _selectColumnChildrenArgs(Ctor, vals, res, idx) {\n  let value,\n      j = idx;\n  let i = -1,\n      n = vals.length;\n\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectColumnChildrenArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Ctor) {\n      j = _selectArgs(Column, value.schema.fields.map((f, i) => Column.new(f, value.getChildAt(i))), res, j).length;\n    } else if (value instanceof Column) {\n      res[j++] = value;\n    }\n  }\n\n  return res;\n}\n/** @ignore */\n\n\nconst toKeysAndValues = (xs, _ref, i) => {\n  let [k, v] = _ref;\n  return xs[0][i] = k, xs[1][i] = v, xs;\n};\n/** @ignore */\n\n\nfunction _selectFieldArgs(vals, ret) {\n  let keys, n;\n\n  switch (n = vals.length) {\n    case 0:\n      return ret;\n\n    case 1:\n      keys = ret[0];\n\n      if (!vals[0]) {\n        return ret;\n      }\n\n      if (isArray(vals[0])) {\n        return _selectFieldArgs(vals[0], ret);\n      }\n\n      if (!(vals[0] instanceof Data || vals[0] instanceof Vector || vals[0] instanceof DataType)) {\n        [keys, vals] = Object.entries(vals[0]).reduce(toKeysAndValues, ret);\n      }\n\n      break;\n\n    default:\n      !isArray(keys = vals[n - 1]) ? (vals = isArray(vals[0]) ? vals[0] : vals, keys = []) : vals = isArray(vals[0]) ? vals[0] : vals.slice(0, n - 1);\n  }\n\n  let fieldIndex = -1;\n  let valueIndex = -1;\n  let idx = -1,\n      len = vals.length;\n  let field;\n  let val;\n  let [fields, values] = ret;\n\n  while (++idx < len) {\n    val = vals[idx];\n\n    if (val instanceof Column && (values[++valueIndex] = val)) {\n      fields[++fieldIndex] = val.field.clone(keys[idx], val.type, true);\n    } else {\n      ({\n        [idx]: field = idx\n      } = keys);\n\n      if (val instanceof DataType && (values[++valueIndex] = val)) {\n        fields[++fieldIndex] = Field.new(field, val, true);\n      } else if (val && val.type && (values[++valueIndex] = val)) {\n        val instanceof Data && (values[valueIndex] = val = Vector.new(val));\n        fields[++fieldIndex] = Field.new(field, val.type, true);\n      }\n    }\n  }\n\n  return ret;\n}","map":{"version":3,"mappings":"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","names":["Data","Field","Column","Vector","DataType","Chunked","isArray","Array","selectArgs","Ctor","vals","_selectArgs","selectColumnArgs","args","fields","values","_selectFieldArgs","map","x","i","new","field","clone","selectFieldArgs","selectChunkArgs","_selectChunkArgs","selectVectorChildrenArgs","_selectVectorChildrenArgs","selectColumnChildrenArgs","_selectColumnChildrenArgs","res","idx","value","j","n","length","chunks","schema","_","getChildAt","f","toKeysAndValues","xs","k","v","ret","keys","Object","entries","reduce","slice","fieldIndex","valueIndex","len","val","type"],"sources":["util/args.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data';\nimport { Field } from '../schema';\nimport { Column } from '../column';\nimport { Vector } from '../vector';\nimport { DataType } from '../type';\nimport { Chunked } from '../vector/chunked';\n\ntype RecordBatchCtor = typeof import('../recordbatch').RecordBatch;\n\nconst isArray = Array.isArray;\n\n/** @ignore */\nexport const selectArgs = <T>(Ctor: any, vals: any[]) => _selectArgs(Ctor, vals, [], 0) as T[];\n/** @ignore */\nexport const selectColumnArgs = <T extends { [key: string]: DataType }>(args: any[]) => {\n    const [fields, values] = _selectFieldArgs<T>(args, [[], []]);\n    return values.map((x, i) =>\n        x instanceof Column ? Column.new(x.field.clone(fields[i]), x) :\n        x instanceof Vector ? Column.new(fields[i], x) as Column<T[keyof T]> :\n                              Column.new(fields[i], [] as Vector<T[keyof T]>[]));\n};\n\n/** @ignore */\nexport const selectFieldArgs = <T extends { [key: string]: DataType }>(args: any[]) => _selectFieldArgs<T>(args, [[], []]);\n/** @ignore */\nexport const selectChunkArgs = <T>(Ctor: any, vals: any[]) => _selectChunkArgs(Ctor, vals, [], 0) as T[];\n/** @ignore */\nexport const selectVectorChildrenArgs = <T extends Vector>(Ctor: RecordBatchCtor, vals: any[]) => _selectVectorChildrenArgs(Ctor, vals, [], 0) as T[];\n/** @ignore */\nexport const selectColumnChildrenArgs = <T extends Column>(Ctor: RecordBatchCtor, vals: any[]) => _selectColumnChildrenArgs(Ctor, vals, [], 0) as T[];\n\n/** @ignore */\nfunction _selectArgs<T>(Ctor: any, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Ctor) { res[j++] = value; }\n    }\n    return res;\n}\n\n/** @ignore */\nfunction _selectChunkArgs<T>(Ctor: any, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectChunkArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Chunked) {\n            j = _selectChunkArgs(Ctor, value.chunks, res, j).length;\n        } else if (value instanceof Ctor) { res[j++] = value; }\n    }\n    return res;\n}\n\n/** @ignore */\nfunction _selectVectorChildrenArgs<T extends Vector>(Ctor: RecordBatchCtor, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectVectorChildrenArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Ctor) {\n            j = _selectArgs(Vector, value.schema.fields.map((_, i) => value.getChildAt(i)!), res, j).length;\n        } else if (value instanceof Vector) { res[j++] = value as T; }\n    }\n    return res;\n}\n\n/** @ignore */\nfunction _selectColumnChildrenArgs<T extends Column>(Ctor: RecordBatchCtor, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectColumnChildrenArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Ctor) {\n            j = _selectArgs(Column, value.schema.fields.map((f, i) => Column.new(f, value.getChildAt(i)!)), res, j).length;\n        } else if (value instanceof Column) { res[j++] = value as T; }\n    }\n    return res;\n}\n\n/** @ignore */\nconst toKeysAndValues = (xs: [any[], any[]], [k, v]: [any, any], i: number) => (xs[0][i] = k, xs[1][i] = v, xs);\n\n/** @ignore */\nfunction _selectFieldArgs<T extends { [key: string]: DataType }>(vals: any[], ret: [Field<T[keyof T]>[], Vector<T[keyof T]>[]]): [Field<T[keyof T]>[], (T[keyof T] | Vector<T[keyof T]>)[]] {\n    let keys: any[], n: number;\n    switch (n = vals.length) {\n        case 0: return ret;\n        case 1:\n            keys = ret[0];\n            if (!(vals[0])) { return ret; }\n            if (isArray(vals[0])) { return _selectFieldArgs(vals[0], ret); }\n            if (!(vals[0] instanceof Data || vals[0] instanceof Vector || vals[0] instanceof DataType)) {\n                [keys, vals] = Object.entries(vals[0]).reduce(toKeysAndValues, ret);\n            }\n            break;\n        default:\n            !isArray(keys = vals[n - 1])\n                ? (vals = isArray(vals[0]) ? vals[0] : vals, keys = [])\n                : (vals = isArray(vals[0]) ? vals[0] : vals.slice(0, n - 1));\n    }\n\n    let fieldIndex = -1;\n    let valueIndex = -1;\n    let idx = -1, len = vals.length;\n    let field: number | string | Field<T[keyof T]>;\n    let val: Vector<T[keyof T]> | Data<T[keyof T]>;\n    let [fields, values] = ret as [Field<T[keyof T]>[], any[]];\n\n    while (++idx < len) {\n        val = vals[idx];\n        if (val instanceof Column && (values[++valueIndex] = val)) {\n            fields[++fieldIndex] = val.field.clone(keys[idx], val.type, true);\n        } else {\n            ({ [idx]: field = idx } = keys);\n            if (val instanceof DataType && (values[++valueIndex] = val)) {\n                fields[++fieldIndex] = Field.new(field, val as DataType, true) as Field<T[keyof T]>;\n            } else if (val && val.type && (values[++valueIndex] = val)) {\n                val instanceof Data && (values[valueIndex] = val = Vector.new(val) as Vector);\n                fields[++fieldIndex] = Field.new(field, val.type, true) as Field<T[keyof T]>;\n            }\n        }\n    }\n    return ret;\n}\n"]},"metadata":{},"sourceType":"module"}