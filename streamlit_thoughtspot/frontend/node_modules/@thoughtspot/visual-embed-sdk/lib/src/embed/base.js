/* eslint-disable import/no-mutable-exports */
/**
 * Copyright (c) 2022
 *
 * Base classes
 *
 * @summary Base classes
 * @author Ayon Ghosh <ayon.ghosh@thoughtspot.com>
 */
import EventEmitter from 'eventemitter3';
import uniq from 'lodash/uniq';
import { getThoughtSpotHost } from '../config';
import { AuthType, PrefetchFeatures } from '../types';
import { authenticate, logout as _logout, AuthFailureType, AuthStatus, } from '../auth';
import { uploadMixpanelEvent, MIXPANEL_EVENT } from '../mixpanel-service';
let config = {};
const CONFIG_DEFAULTS = {
    loginFailedMessage: 'Not logged in',
    authTriggerText: 'Authorize',
    authType: AuthType.None,
};
export let authPromise;
export const getEmbedConfig = () => config;
export const getAuthPromise = () => authPromise;
let authEE;
export function notifyAuthSDKSuccess() {
    if (!authEE) {
        console.error('SDK not initialized');
        return;
    }
    authEE.emit(AuthStatus.SDK_SUCCESS);
}
export function notifyAuthSuccess() {
    if (!authEE) {
        console.error('SDK not initialized');
        return;
    }
    authEE.emit(AuthStatus.SUCCESS);
}
export function notifyAuthFailure(failureType) {
    if (!authEE) {
        console.error('SDK not initialized');
        return;
    }
    authEE.emit(AuthStatus.FAILURE, failureType);
}
export function notifyLogout() {
    if (!authEE) {
        console.error('SDK not initialized');
        return;
    }
    authEE.emit(AuthStatus.LOGOUT);
}
/**
 * Perform authentication on the ThoughtSpot app as applicable.
 */
export const handleAuth = () => {
    authPromise = authenticate(config);
    authPromise.then((isLoggedIn) => {
        if (!isLoggedIn) {
            notifyAuthFailure(AuthFailureType.SDK);
        }
        else {
            notifyAuthSDKSuccess();
        }
    }, () => {
        notifyAuthFailure(AuthFailureType.SDK);
    });
    return authPromise;
};
const hostUrlToFeatureUrl = {
    [PrefetchFeatures.SearchEmbed]: (url) => `${url}v2/#/embed/answer`,
    [PrefetchFeatures.LiveboardEmbed]: (url) => url,
    [PrefetchFeatures.FullApp]: (url) => url,
    [PrefetchFeatures.VizEmbed]: (url) => url,
};
/**
 * Prefetches static resources from the specified URL. Web browsers can then cache the prefetched resources and serve them from the user's local disk to provide faster access to your app.
 * @param url The URL provided for prefetch
 * @param prefetchFeatures Specify features which needs to be prefetched.
 * @version SDK: 1.4.0 | ThoughtSpot: ts7.sep.cl, 7.2.1
 */
export const prefetch = (url, prefetchFeatures) => {
    if (url === '') {
        // eslint-disable-next-line no-console
        console.warn('The prefetch method does not have a valid URL');
    }
    else {
        const features = prefetchFeatures || [PrefetchFeatures.FullApp];
        let hostUrl = url || config.thoughtSpotHost;
        hostUrl = hostUrl[hostUrl.length - 1] === '/' ? hostUrl : `${hostUrl}/`;
        uniq(features.map((feature) => hostUrlToFeatureUrl[feature](hostUrl))).forEach((prefetchUrl, index) => {
            const iFrame = document.createElement('iframe');
            iFrame.src = prefetchUrl;
            iFrame.style.width = '0';
            iFrame.style.height = '0';
            iFrame.style.border = '0';
            iFrame.classList.add('prefetchIframe');
            iFrame.classList.add(`prefetchIframeNum-${index}`);
            document.body.appendChild(iFrame);
        });
    }
};
function sanity(embedConfig) {
    if (embedConfig.thoughtSpotHost === undefined) {
        throw new Error('ThoughtSpot host not provided');
    }
    if (embedConfig.authType === AuthType.TrustedAuthToken) {
        if (!embedConfig.username) {
            throw new Error('Username not provided with Trusted auth');
        }
        if (!embedConfig.authEndpoint &&
            typeof embedConfig.getAuthToken !== 'function') {
            throw new Error('Trusted auth should provide either authEndpoint or getAuthToken');
        }
    }
    if (embedConfig.noRedirect && !embedConfig.authTriggerContainer) {
        throw new Error('authTriggerContainer not provided with noRedirect');
    }
}
/**
 * Initializes the Visual Embed SDK globally and perform
 * authentication if applicable.
 * @param embedConfig The configuration object containing ThoughtSpot host,
 * authentication mechanism and so on.
 * example: authStatus = init(config);
 * authStatus.on(AuthStatus.FAILURE, (reason) => { // do something here });
 * @returns event emitter which emits events on authentication success, failure and logout. See {@link AuthStatus}
 * @version SDK: 1.0.0 | ThoughtSpot ts7.april.cl, 7.2.1
 */
export const init = (embedConfig) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    sanity(embedConfig);
    config = {
        ...CONFIG_DEFAULTS,
        ...embedConfig,
        thoughtSpotHost: getThoughtSpotHost(embedConfig),
    };
    authEE = new EventEmitter();
    handleAuth();
    uploadMixpanelEvent(MIXPANEL_EVENT.VISUAL_SDK_CALLED_INIT, {
        authType: config.authType,
        host: config.thoughtSpotHost,
        usedCustomizationSheet: ((_b = (_a = embedConfig.customizations) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.customCSSUrl) != null,
        usedCustomizationVariables: ((_e = (_d = (_c = embedConfig.customizations) === null || _c === void 0 ? void 0 : _c.style) === null || _d === void 0 ? void 0 : _d.customCSS) === null || _e === void 0 ? void 0 : _e.variables) != null,
        usedCustomizationRules: ((_h = (_g = (_f = embedConfig.customizations) === null || _f === void 0 ? void 0 : _f.style) === null || _g === void 0 ? void 0 : _g.customCSS) === null || _h === void 0 ? void 0 : _h.rules_UNSTABLE) !=
            null,
    });
    if (config.callPrefetch) {
        prefetch(config.thoughtSpotHost);
    }
    return authEE;
};
export function disableAutoLogin() {
    config.autoLogin = false;
}
/**
 * Logs out from ThoughtSpot. This also sets the autoLogin flag to false, to prevent
 * the SDK from automatically logging in again.
 *
 * You can call the `init` method again to re login, if autoLogin is set to true in this
 * second call it will be honored.
 *
 * @param doNotDisableAutoLogin This flag when passed will not disable autoLogin
 * @returns Promise which resolves when logout completes.
 * @version SDK: 1.10.1 | ThoughtSpot: 8.2.0.cl, 8.4.1-sw
 */
export const logout = (doNotDisableAutoLogin = false) => {
    if (!doNotDisableAutoLogin) {
        disableAutoLogin();
    }
    return _logout(config).then((isLoggedIn) => {
        notifyLogout();
        return isLoggedIn;
    });
};
let renderQueue = Promise.resolve();
/**
 * Renders functions in a queue, resolves to next function only after the callback next is called
 * @param fn The function being registered
 */
export const renderInQueue = (fn) => {
    const { queueMultiRenders = false } = config;
    if (queueMultiRenders) {
        renderQueue = renderQueue.then(() => new Promise((res) => fn(res)));
        return renderQueue;
    }
    // Sending an empty function to keep it consistent with the above usage.
    return fn(() => { }); // eslint-disable-line @typescript-eslint/no-empty-function
};
// For testing purposes only
export function reset() {
    config = {};
    authEE = null;
    authPromise = null;
}
//# sourceMappingURL=base.js.map